<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Chatterbox: HTTP/2 for Erlang</title>

    <meta name="description" content="An Introduction to HTTP/2 and the code that implements it">
    <meta name="author" content="Joe DeVivo">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/abba.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>Take a Chance<br/>on HTTP</h1>
          <h3>Chatterbox: HTTP/2 for Erlang</h3>
          <img src="./img/crown.png" style="border:0px"/>
          <p>
            <small>Joe DeVivo / <a href="http://twitter.com/joedevivo">@joedevivo</a></small>
          </p>
          <center>
            <div style="height: 3px; width:100px; background: #b89c30; align: center;"></div>
          </center>
        </section>

        <section>
          <h2>A (Hopefully) Breif History of HTTP</h2>
        </section>

        <!-- HTTP/0.9 -->
        <section>
          <section>
            <h2>HTTP/0.9</h2>
            <p>On the scene in 1991</p>
            <ul>
              <li>Single Line Request: GET /&lt;path&gt;</li>
              <li>Request ends on CRLF</li>
              <li>Only responds with HTML ASCII</li>
              <li>When that's done, Connection over</li>
            </ul>
            <aside class="notes">
              I start here just to show how simple it was. And...
            </aside>
          </section>

          <section>
            <p>HTTP/0.9 Is still out there!</p>
            <p>tl;dr - ask for an HTML file and you'll get one</p>
          </section>
        </section>

        <!-- HTTP/1.0 -->
        <section>
          <section>
            <h2>HTTP/1.0</h2>
            <p>
              1996 - <a href="http://tools.ietf.org/html/rfc1945">RFC-1945: HTTP/1.0</a>
            </p>
            <p> New Features! </p>
            <ul>
              <li>HEADERS! Request and Response</li>
              <li>Response Codes</li>
              <li>Serves file types other than HTML</li>
            </ul>
            <aside class="notes">Supporting non-HTML files took the "HT" out of "HTTP"</aside>
          </section>

          <section>
            <h2>HTTP/1.0 Lifecycle</h2>
            <ul>
              <li>Request headers separated by CRLF</li>
              <li>2x CRLF means request is done</li>
              <li>Status Code as first line of response</li>
              <li>Response headers separated by CRLF</li>
              <li>Connection closed after every request</li>
            </ul>

            <aside class="notes">
              Still plain text.
            </aside>
          </section>

          <section>
            <h2>HTTP/1.0</h2>
            <p>It really wasn't a standard</p>
            <aside class="notes">
              Kind of a reverse spec of everything that was already happening.
            </aside>
          </section>
        </section>

        <section>
          <h2>HTTP/1.1</h2>
          <p>1997 - <a href="http://tools.ietf.org/html/rfc2068">RFC-2068: HTTP/1.1</a></p>
          <p>1999 - <a href="http://tools.ietf.org/html/rfc2616">RFC-2616: HTTP/1.1</a></p>
          <aside class="notes">
            HTTP/1.1 was here to resolve ambiguities in HTTP/1.0 and introduce performance optimizations
          </aside>
        </section>

        <section>
          <h2>New Features</h2>
          <ul>
            <li>Keepalive Connections</li>
            <li>Chunked Transfers</li>
            <li>Request Pipelining</li>
            <li>Byte-Range Requests</li>
            <li>Transfer Encodings</li>
            <li>Close connection with 'Connection: close' header</li>
            <li>Negotiation of: charsets, caching, language, encoding, and more</li>
          </ul>

          <aside class="notes">
            Chunked encoding for unknown content lengths. headers after the body. Point is, there's a lot added to 1.1.
          </aside>
        </section>

        <section>
          <section>
            <h2>HTTP/1.1 Lifecycle</h2>
            <p>More Complex</p>
          </section>
          <section>
            <h2>HTTP/1.1 Request</h2>
            <ul>
              <li>Still Plaintext</li>
              <li>Still one header per line</li>
              <li>Still 2x CRLF to terminate</li>
            </ul>
            <h4>Possible Chunked Data</h4>
          </section>
          <section>
            <h2>HTTP/1.1 Response</h2>
            <ul>
              <li>Still starts with a response code</li>
              <li>Still has one response header per line</li>
            </ul>
            <h4>Possible Chunked Data</h4>
          </section>
          <section>
            <h2>Connection not closed!</h2>
          </section>
          <section>
            <h2>HTTP/1.1 tl;dr</h2>
            <ul>
            <li>Request</li>
            <li>Response</li>
            <li>Repeat</li>
            </ul>
            <p>All on one connection!</p>
            <p>Act now! Supplies are limited!</p>
            <aside class="notes">Really, it's a problem.</aside>
          </section>
          <section>
            <h2>Side note on HTTP/1.0</h2>
            <p>Keepalive connections were backported to HTTP/1.0, but it's disabled by default</p>
          </section>
          <section>
            <h2>HTTP/1.1 Spec is HUGE</h2>
            <p>In 2014's special edition remaster, HTTP/1.1 was split into SIX RFCs totaling over 292 pages</p>
          </section>

          <section>
            <h2>Many HTTP/1.1 Features are OPTIONAL</h2>
            <p>Like Pipelining</p>
            <p>Very rare to find a single product implementing the full feature set</p>
            <aside class="notes">
              that means a lot software talking to each other, that have different feature sets
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h2>On HTTP/1.1's TCP Useage</h2>
          </section>
          <section>
            <h2>It uses less connections because 'Keepalive'</h2>
            <p>That's good!</p>
          </section>
          <section>
            <h2>It sequentially sends requests and receives responses in order via Pipelining</h2>
            <p>That's bad!</p>
            <p>Well, sometimes. Be responsible</p>
          </section>
          <section>
            <h2>Head of line Blocking</h2>
            <ul>
              <li>Pipelining lets you send another request before the first one responds</li>
              <li>It will not respond until the first response is fully served</li>
              <li>Most browsers disable pipelining by default</li>
            </ul>
          </section>
          <section>
            <h2>Performance Hacks</h2>
            <ul>
              <li>Spriting</li>
              <li>Inlining</li>
              <li>Concatenation</li>
              <li>Sharding</li>
            </ul>
            <aside class="notes">
              Spriting/Inlinging - Different ways of serving a large file, and then displaying different parts in differnt places.
              Concatenation - Manually merging javascript files, so they're one file
              Sharding - Different files on different servers = more connections open
            </aside>
          </section>

          <section>
            <h2>Transfer Sizes</h2>
            <h2>Dec/2010 - Apr/2015</h2>
            <img src="./img/chart2.png"/>
            <p>Transfer sizes and quantities are going UP!</p>
          </section>
        </section>

        <section>
          <section>
            <h2>HTTP/2 Abstract</h2>
            <p>
  This specification describes an optimized expression of the semantics
  of the Hypertext Transfer Protocol (HTTP), referred to as HTTP
  version 2 (HTTP/2).  HTTP/2 enables a <b>more efficient use of network
  resources</b> and a <b>reduced perception of latency</b> by introducing <b>header
  field compression</b> and <b>allowing multiple concurrent exchanges on the
  same connection</b>.  It also introduces <b>unsolicited push of
  representations from servers</b> to clients.
  </p><p>
  This specification is an alternative to, but does not obsolete, the
  HTTP/1.1 message syntax.  <b>HTTP’s existing semantics remain unchanged.</b>
  </p>
          </section>

          <section>
            <h2>Goals of an HTTP Update</h2>
            <ul>
              <li>more efficient use of network resources</li>
              <li>reduced perception of latency</li>
              <li>header field compression</li>
              <li>allowing multiple concurrent exchanges on the same connection</li>
              <li>unsolicited push of representations from servers</li>
              <li>HTTP’s existing semantics remain unchanged.</li>
            </ul>
          </section>

          <section>
            <h2>SPDY</h2>
            <p>Google tried to fix this and pretty much proved it could work</p>
          </section>

          <section>
            <h2>s/SPDY\/3/http2 draft-00</h2>
            <p>One day, the SPDY/3 draft became the HTTP/2 draft</p>
          </section>
        </section>
        <section>
          <h2>HTTP/2</h2>
          <p>
            2015 - <a href="http://tools.ietf.org/html/rfc7540">RFC 7540</a>
          </p>

          <ul>
            <li>You can keep your semantics</li>
            <li>Binary Protocol</li>
            <li>Header Compression</li>
            <li>Mulitplexing</li>
            <li>Frames</li>
            <li>Flow Control</li>
            <li>Prioritization (Maybe?)</li>
            <li>Server Push</li>
            <li>Upgrading HTTP/1 requests</li>
          </ul>
        </section>

        <!-- semantics -->
        <section>
          <section>
            <h2>Keep your semantics</h2>
            <ul>
              <li>methods: GET, POST, and Friends</li>
              <li>Headers!</li>
              <li>Requests</li>
              <li>Responses</li>
              <li>if you did it before, it should still work</li>
            </ul>
          </section>
          <section>
            <h2>Technically that means</h2>
            <ul>

              <li><a href="http://tools.ietf.org/html/rfc7231">RFC 7231</a>: HTTP/1.1 Semantics and Content</li>
              <li><a href="http://tools.ietf.org/html/rfc7232">RFC 7232</a>: HTTP/1.1 Conditional Request</li>
              <li><a href="http://tools.ietf.org/html/rfc7233">RFC 7233</a>: HTTP/1.1 Range Requests</li>
              <li><a href="http://tools.ietf.org/html/rfc7234">RFC 7234</a>: HTTP/1.1 Caching</li>
              <li><a href="http://tools.ietf.org/html/rfc7235">RFC 7235</a>: HTTP/1.1 Authentication</li>
              <li>And parts of <a href="http://tools.ietf.org/html/rfc7230">RFC 7230</a>: HTTP/1.1 Mesage Syntax and Routing</li>
            </ul>
          </section>
        </section>

        <!-- binary -->
        <section>
          <section>
            <h2>Binary Protocol</h2>
            <ul>
              <li>Bye Bye Telnet</li>
              <li>Bleep blorp</li>
              <li>Binaries make the spec less ambigous</li>
            </ul>
          </section>
          <section>
            <h2>Binaries =:= Happy Erlangers</h2>
          </section>
        </section>

        <!-- hpack -->
        <section>
          <section>
            <h2>Header Compression</h2>
            <ul>
              <li>Stateless protocols are repetitive</li>
              <li>HTTP is stateless</li>
            </ul>
          </section>
          <section>
            <h2>HPACK - <a href="http://tools.ietf.org/html/rfc7541">RFC 7541</a></h2>
            <p>A whole RFC just for header compression!</p>
          </section>
          <section>
            <h2>Compression Context is Stateful</h2>
            <p>
              By having a stateful context for compression, you can send the same header 100 times over a connection, but after the first time the client and server will have agreed on a much smaller binary value.
            </p>
          </section>
          <section>
            <h2>There Are Four Contexts!</h2>
            <p>Given two peers: X &amp; Y, connected over C1 </p>
            <ul>
              <li>Context A1: encoding outbound requests on X to Y over C1</li>
              <li>Context A2: decoding inbound requests on Y from X over C1</li>
              <li>Context B1: encoding outbound responses on Y to X over C1</li>
              <li>Context B2: decoding inbound responses on X from Y over C1</li>
            </ul>

            <aside class="notes">
              Two for each peer, Maybe easier to think of as one for Requests and one for Responses. If you open multiple connections, there will be 4 contexts per connection, but you wouldn't do that because you can multiplex :D
            </aside>
          </section>
          <section>
            <h2>The Basic Case</h2>
<pre>                    +---------------+           +---------------+
                    |Peer X (Client)|           |Peer Y (Server)|
+-------------------+---------------+           +---------------+-------------------+
|                                   |           |                                   |
| +----------+   +-----------+   +--+-----------+--+   +-----------+   +----------+ |
| |Plain Req |   |Encode (A1)|   | Encoded Request |   |Decode (A2)|   |Plain Req | |
| | Headers  |-->|  Context  |-->|     Headers     |-->|  Context  |-->| Headers  | |
| +----------+   +-----------+   +--+-----------+--+   +-----------+   +----------+ |
|                                   |   Cloud   |                                   |
| +----------+   +-----------+   +--+-----------+--+   +-----------+   +----------+ |
| |Plain Resp|   |Decode (B2)|   |Encoded Response |   |Encode (B1)|   |Plain Resp| |
| | Headers  |<--|  Context  |<--|     Headers     |<--+- Context  |<--| Headers  | |
| +----------+   +-----------+   +--+-----------+--+   +-----------+   +----------+ |
|                                   |           |                                   |
|                                   |           |                                   |
+-----------------------------------+           +-----------------------------------+</pre>
          </section>
          <section>
            <h2>A More interesting case</h2>
            <pre>                    +---------------+           +---------------+
                    |Peer X (Client)|           |Peer Y (Server)|
+-------------------+---------------+           +---------------+-------------------+
|                                   |           |                                   |
| +----------+   +-----------+   +--+-----------+--+   +-----------+   +----------+ |
| |Plain Req |   |           |   | Encoded Request |   |           |   |Plain Req | |
| |Headers #1|-->|           |-->|   Headers #1    |-->|           |-->|Headers #1| |
| +----------+   |           |   +--+-----------+--+   |           |   +----------+ |
| +----------+   |           |   +--+-----------+--+   |           |   +----------+ |
| |Plain Req |   |           |   | Encoded Request |   |           |   |Plain Req | |
| |Headers #2|-->|           |-->|   Headers #2    |-->|           |-->|Headers #2| |
| +----------+   |Encode (A1)|   +--+-----------+--+   |Decode (A2)|   +----------+ |
| +----------+   |  Context  |   +--+-----------+--+   |  Context  |   +----------+ |
| |Plain Req |   |           |   | Encoded Request |   |           |   |Plain Req | |
| |Headers #2|-->|           |-->|   Headers #3    |-->|           |-->|Headers #3| |
| +----------+   |           |   +--+-----------+--+   |           |   +----------+ |
| +----------+   |           |   +--+-----------+--+   |           |   +----------+ |
| |Plain Req |   |           |   | Encoded Request |   |           |   |Plain Req | |
| |Headers #2+-->|           |-->|   Headers #4    |-->|           |-->|Headers #4| |
| +----------+   +-----------+   +--+-----------+--+   +-----------+   +----------+ |
|                                   |           |                                   |
| +----------+   +-----------+   +--+-----------+--+   +-----------+   +----------+ |
| |Plain Resp|   |Decode (B2)|   |Encoded Response |   |Encode (B1)|   |Plain Resp| |
| | Headers  |<--|  Context  |<--|     Headers     |<--|  Context  |<--| Headers  | |
| +----------+   +-----------+   +--+-----------+--+   +-----------+   +----------+ |
+-----------------------------------+           +-----------------------------------+
</pre></section>
          <section>

            <h2>The Static Table</h2>
            <!--table>
              <thead>
                <tr>
                  <th>Index</th>
                  <th>Header Name</th>
                  <th>Header Value</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>1 </td><td>:authority     </td><td>             </td></tr>
                <tr><td>2 </td><td>:method        </td><td>GET          </td></tr>
                <tr><td>3 </td><td>:method        </td><td>POST         </td></tr>
                <tr><td>4 </td><td>:path          </td><td>/            </td></tr>
                <tr><td>5 </td><td>:path          </td><td>/index.html  </td></tr>
                <tr><td>6 </td><td>:scheme        </td><td>http         </td></tr>
                <tr><td>7 </td><td>:scheme        </td><td>https        </td></tr>
                <tr><td>8 </td><td>:status        </td><td>200          </td></tr>
                <tr><td>9 </td><td>:status        </td><td>204          </td></tr>
                <tr><td>10</td><td>:status        </td><td>206          </td></tr>
                <tr><td>11</td><td>:status        </td><td>304          </td></tr>
                <tr><td>12</td><td>:status        </td><td>400          </td></tr>
                <tr><td>13</td><td>:status        </td><td>404          </td></tr>
                <tr><td>14</td><td>:status        </td><td>500          </td></tr>
                <tr><td>15</td><td>accept-charset </td><td>             </td></tr>
                <tr><td>16</td><td>accept-encoding</td><td>gzip, deflate</td></tr>
              </tbody>
            </table-->
<pre>
                    +-------+--------------------+---------------+
                    | Index | Header Name        | Header Value  |
                    +-------+--------------------+---------------+
                    | 1     | :authority         |               |
                    | 2     | :method            | GET           |
                    | 3     | :method            | POST          |
                    | 4     | :path              | /             |
                    | 5     | :path              | /index.html   |
                    | 6     | :scheme            | http          |
                    | 7     | :scheme            | https         |
                    | 8     | :status            | 200           |
                    | 13    | :status            | 404           |
                    | 14    | :status            | 500           |
                    | 15    | accept-charset     |               |
                    | 16    | accept-encoding    | gzip, deflate |
                                        ...
                    | 57    | transfer-encoding  |               |
                    | 58    | user-agent         |               |
                    | 59    | vary               |               |
                    | 60    | via                |               |
                    | 61    | www-authenticate   |               |
                    +-------+--------------------+---------------+
</pre>
            <aside class="notes">
              These are for really common headers. e.g. A response code of 200 is just going to be represented by "8".
              Sometimes there's no value, but the header name is what we're saving here, so 15+value is always "accept-charset"
            </aside>
          </section>
          <section>
            <ul>
              <li>Indexes 1-61</li>
              <li>Sometimes value, sometimes not</li>
            </ul>
          </section>
          <section>
            <h2>The Dynamic Table</h2>
            <p>Indexes 62+</p>
          </section>
          <section>
            <p>
              Bounded by size in HTTP/2 connection settings as a security precaution
            </p>
          </section>
          <section>
            <h2>How "H" Packs</h2>
          </section>
          <section>
            <h2>Data Types</h2>
            <ul>
              <li>Numbers</li>
              <li>Strings</li>
            </ul>
          </section>
          <section>
            <h2>Indexed Header Field</h2>
            <pre>
                            0   1   2   3   4   5   6   7
                          +---+---+---+---+---+---+---+---+
                          | 1 |        Index (7+)         |
                          +---+---------------------------+
            </pre>
            <aside class="notes">
              A Name/Value pair already in the table
            </aside>
          </section>

          <section>
            <h2>Literal Header Field w/ Index</h2>
            <pre>
                            0   1   2   3   4   5   6   7
                          +---+---+---+---+---+---+---+---+
                          | 0 | 1 |      Index (6+)       |
                          +---+---+-----------------------+
                          | H |     Value Length (7+)     |
                          +---+---------------------------+
                          | Value String (Length octets)  |
                          +-------------------------------+
            </pre>
            <aside class="notes">
              A Name that's already in the table, but a different value
            </aside>
          </section>

          <section>
            <h2>Literal Header Field w/ Index</h2>
            <pre>
                            0   1   2   3   4   5   6   7
                          +---+---+---+---+---+---+---+---+
                          | 0 | 1 |           0           |
                          +---+---+-----------------------+
                          | H |     Name Length (7+)      |
                          +---+---------------------------+
                          |  Name String (Length octets)  |
                          +---+---------------------------+
                          | H |     Value Length (7+)     |
                          +---+---------------------------+
                          | Value String (Length octets)  |
                          +-------------------------------+
            </pre>
            <aside class="notes">
              Neither the name nor value are in the table
            </aside>
          </section>

          <section>
            <h2>Types of Literal Fields</h2>
            <ul>
              <li>with Indexing - added to the dynamic table</li>
              <li>without Indexing - not added to the DT</li>
              <li>never Indexed - never added to any DT</li>
            </ul>
            <aside class="notes">
              All three are ways of saying the same thing, as far as "here's a header and value, but some are not compressed. "never" means no proxies can compress it either, while "without" applies to just one hop.
            </aside>
          </section>

          <section>
            <h2>Huffman Encoding</h2>
            <ul>
              <li>Designed for HTTP</li>
              <li>The more common the ASCII character, the fewer bytes it takes</li>
            </ul>
            <aside class="notes">Did you see that "H" bit?</aside>
          </section>
          <section>
<pre>
                                                              code
                                code as bits                 as hex   len
              sym              aligned to MSB                aligned   in
                                                             to LSB   bits
             (  0)  |11111111|11000                             1ff8  [13]
             (  1)  |11111111|11111111|1011000                7fffd8  [23]
             (  2)  |11111111|11111111|11111110|0010         fffffe2  [28]
             (  3)  |11111111|11111111|11111110|0011         fffffe3  [28]
             (  4)  |11111111|11111111|11111110|0100         fffffe4  [28]
                                     ...
         '0' ( 48)  |00000                                         0  [ 5]
         '1' ( 49)  |00001                                         1  [ 5]
         '2' ( 50)  |00010                                         2  [ 5]
         '3' ( 51)  |011001                                       19  [ 6]
         '4' ( 52)  |011010                                       1a  [ 6]
                                     ...
         'X' ( 88)  |11111100                                     fc  [ 8]
         'Y' ( 89)  |1110011                                      73  [ 7]
         'Z' ( 90)  |11111101                                     fd  [ 8]
         '[' ( 91)  |11111111|11011                             1ffb  [13]
         '\' ( 92)  |11111111|11111110|000                     7fff0  [19]
         ']' ( 93)  |11111111|11100                             1ffc  [13]
         '^' ( 94)  |11111111|111100                            3ffc  [14]
         '_' ( 95)  |100010                                       22  [ 6]
         '`' ( 96)  |11111111|1111101                           7ffd  [15]
         'a' ( 97)  |00011                                         3  [ 5]
         'b' ( 98)  |100011                                       23  [ 6]
         'c' ( 99)  |00100                                         4  [ 5]
         'd' (100)  |100100                                       24  [ 6]
         'e' (101)  |00101                                         5  [ 5]
</pre>
            <aside class="notes">
              See?! Weird things like "non visualizable ASCII code 3" are 28 bits, but useful things like "1" are 5 bits. We're all about optimizing the wire
            </aside>
          </section>
          <section>
            <h2>Examples</h2>
            <p>
              There are tons of cool examples in <a href="http://tools.ietf.org/html/rfc7541#appendix-C">HPACK: Appendix C</a>. They're so good that I turned them into <a href="https://github.com/joedevivo/chatterbox/blob/master/test/hpack_tests.erl#L60">EUnit tests</a>
            </p>
          </section>
        </section>

        <!-- HPACK Example -->
        <section>
          <section>
            <h2>HPACK Tables Example</h2>
          </section>
          <section>
            <pre><code data-trim contenteditable class="erlang">
Headers1 = [
           {<<":path">>, <<"/">>},
           {<<"user-agent">>, <<"my cool browser">>},
           {<<"x-custom-header">>, <<"some custom value">>}
          ],
HeaderContext1 = hpack:new_encode_context(),
{HeadersBin1, HeaderContext2} = hpack:encode(Headers1, HeaderContext1),

Headers2 = [
           {<<":path">>, <<"/some_file.html">>},
           {<<"user-agent">>, <<"my cool browser">>},
           {<<"x-custom-header">>, <<"some custom value">>}
          ],
{HeadersBin2, HeaderContext3} = hpack:encode(Headers2, HeaderContext2),

Headers3 = [
           {<<":path">>, <<"/some_file.html">>},
           {<<"user-agent">>, <<"my cool browser">>},
           {<<"x-custom-header">>, <<"new value">>}
          ],
{HeadersBin3, _HeaderContext4} = hpack:encode(Headers3, HeaderContext3),
  </code></pre>
          </section>
          <section>
            <h2>Request 1</h2>
            <pre><code data-trim contenteditable class="erlang">
%% Request 1
                Headers1 = [
                 {<<":path">>, <<"/">>},
                 {<<"user-agent">>, <<"my cool browser">>},
                 {<<"x-custom-header">>, <<"some custom value">>}
                ],
  </code></pre>
          </section>
          <!--section>
<pre>
:path - "/"
    - Index 4
user-agent - "my cool browser"
    - Index 58, Literal Value "my cool browser"
x-custom-header - "some custom value"
     - Indexed new name, "x-custom-header", "some custom value"
</pre>
          </section-->
          <section>
            <h4>Wiresharked R1</h4>
<pre>
        Header: :path: /
            Name Length: 5
            Name: :path
            Value Length: 1
            Value: /
            Representation: Indexed Header Field
            Index: 4
        Header: user-agent: my cool browser
            Name Length: 10
            Name: user-agent
            Value Length: 15
            Value: my cool browser
            Representation: Literal Header Field with Incremental Indexing - Indexed Name
            Index: 58
        Header: x-custom-header: some custom value
            Name Length: 15
            Name: x-custom-header
            Value Length: 17
            Value: some custom value
            Representation: Literal Header Field with Incremental Indexing - New Name
</pre>
            <aside class="notes">Look at the first and second headers' index, and the third has none</aside>
          </section>

          <section>
            <h2>R1 Context updates</h2>
<pre><code data-trim contenteditable class="erlang">
DynamicTable = [
                {62,<<"x-custom-header">>,<<"some custom value">>},
                {63,<<"user-agent">>,     <<"my cool browser">>}
]
</code></pre>
            <ul>
              <li>:path changes nothing</li>
              <li>"user-agent"/"my cool browser" is now Index 62</li>
              <li>"x-custom-header"/"some custom value" is now Index 62
              <li>"user-agent"/"my cool browser" is +1'd to 63</li>
            </ul>
          </section>

          <section>
            <h2>Request 2</h2>
            <pre><code data-trim contenteditable class="erlang">
%% Request 2
               Headers2 = [
                {<<":path">>, <<"/some_file.html">>},
                {<<"user-agent">>, <<"my cool browser">>},
                {<<"x-custom-header">>, <<"some custom value">>}
               ],
  </code></pre>
          </section>
          <!--section>
<pre>
:path - "/some_file.html"
  - Index 4, Literal Value "/some_file.html"
user-agent - "my cool browser"
  - Index 63
x-custom-header - "some custom value"
  - Index 62
</pre>
          </section-->
          <section>
            <h4>Wiresharked R2</h4>
<pre>
        Header: :path: /some_file.html
            Name Length: 5
            Name: :path
            Value Length: 15
            Value: /some_file.html
            Representation: Literal Header Field with Incremental Indexing - Indexed Name
            Index: 4
        Header: user-agent: my cool browser
            Name Length: 10
            Name: user-agent
            Value Length: 15
            Value: my cool browser
            Representation: Indexed Header Field
            Index: 64
        Header: x-custom-header: some custom value
            Name Length: 15
            Name: x-custom-header
            Value Length: 17
            Value: some custom value
            Representation: Indexed Header Field
            Index: 63
</pre>
            <aside class="notes">Look at those indexes? 64 &amp; 63? Didn't I just say 62 &amp; 63? Yes! It's because the encoding context is updated per header, not per request. Ordering!</aside>
          </section>
          <section>
            <h2>R2: Context updates</h2>
<pre><code data-trim contenteditable class="erlang">
[
                {62,<<":path">>,          <<"/some_file.html">>},
                {63,<<"x-custom-header">>,<<"some custom value">>},
                {64,<<"user-agent">>,     <<"my cool browser">>}
]
</code></pre>
            <ul>
              <li>":path"/"/some_file.html" is the new Index 62</li>
              <li>"x-custom-header"/"some custom value" is +1'd 63</li>
              <li>"user-agent"/"my cool browser" is +1'd to 64</li>
            </ul>
            <aside class="notes">
              FIFO queue. First in, First out. Falls of the end.
            </aside>
          </section>
          <section>
            <h2>Request 3</h2>
            <pre><code data-trim contenteditable class="erlang">
              %% Request 3
                    Headers3 = [
                     {<<":path">>, <<"/some_file.html">>},
                     {<<"user-agent">>, <<"my cool browser">>},
                     {<<"x-custom-header">>, <<"new value">>}
                    ],
  </code></pre>
          </section>
          <!--section>
<pre>
:path - "/some_file.html"
  - Index 62
user-agent - "my cool browser"
  - Index 64
x-custom-header - "new value"
  - Index 63, Literal Value "new value"
</pre>
          </section-->
          <section>
            <h4>Wiresharked R3</h4>
<pre>
       Header: :path: /some_file.html
            Name Length: 5
            Name: :path
            Value Length: 15
            Value: /some_file.html
            Representation: Indexed Header Field
            Index: 62
        Header: user-agent: my cool browser
            Name Length: 10
            Name: user-agent
            Value Length: 15
            Value: my cool browser
            Representation: Indexed Header Field
            Index: 64
        Header: x-custom-header: new value
            Name Length: 15
            Name: x-custom-header
            Value Length: 9
            Value: new value
            Representation: Literal Header Field with Incremental Indexing - Indexed Name
            Index: 63
</pre>
          </section>
          <section>
            <h2>R3: Context updates</h2>
<pre><code data-trim contenteditable class="erlang">
[
  {62,<<"x-custom-header">>,<<"new value">>},
  {63,<<":path">>,          <<"/some_file.html">>},
  {64,<<"x-custom-header">>,<<"some custom value">>},
  {65,<<"user-agent">>,     <<"my cool browser">>}
]
</code></pre>
            <ul>
              <li>"x-custom-header"/"new value" is the new 62</li>
              <li>":path"/"/some_file.html" is +1'd to 63</li>
              <li>"x-custom-header"/"some custom value" is +1'd 64</li>
              <li>"user-agent"/"my cool browser" is +1'd to 65</li>
            </ul>
            <aside="notes">
              when the sum of the sizes of name/value pairs exceedes the maximum table size, that last header falls off the end. bye!
            </aside>
          </section>

        </section>

        <!-- this is an interesting bug, but not something i have time for in this presentation. -->
        <!--section>
          <section>
            <h2>Debugging This Slide Deck</h2>
            <h2>With Wireshark</h2>
          </section>
          <section>
            <pre>
        Header: x-custom-header: new value
            Name Length: 15
            Name: x-custom-header
            Value Length: 9
            Value: new value
            Representation: Literal Header Field with Incremental Indexing - Indexed Name
            Index: 63
            </pre>
            <aside class="notes">I had such a hard time getting this to appear in wireshark.</aside>
          </section>
          <section>
            <h2>Why?</h2>
            <p>Index : 63</p>
            <p>Binary: 111111</p>
          </section>
        <section-->
        <!-- Multiplexing -->
        <section>
          <section>
            <h2>Multiplexing: Pipelining done right</h2>
          </section>
          <section>
            <h2>Streams</h2>
            <p>There's one connection, streams are logical abstractions across it</p>
            <p>They have unique identifiers</p>
            <p>Section 5.1.1 says client initiated stream ids are odd, server's are even</p>
          </section>
          <section>
            <h2>Stream 0</h2>
            <p>Stream 0 is the meta stream. Frames sent to it apply to the entire connection</p>
            <p>Some frame types (e.g. Data) can't be sent to stream 0.</p>
          </section>
          <section>
            <h2>Frames</h2>
            <p>A frame's stream identifier determines which multiplexed stream it belongs to</p>
          </section>
          <section>
            <h2>One Stream Id</h2>
            <h2>per frame</h2>
            <p>A series of frames for each stream id is reconstructed on the other side, in the order they arrive</p>
          </section>
          <section>
            <h2>Order?</h2>
            <p>Yes, because the header context is a piece of state, all those HPACK indexes would get out of sync if the client and server processed things in a different order</p>
          </section>
          <section>
            <h2>Order Matters</h2>
<pre>
+---------------+           +---------------+
|Peer X (Client)|           |Peer Y (Server)|
+---------------+           +---------------+------------------------------+
                |           |                                              |
---------+   +--+-----------+--+              +-----------+   +----------+ |
         |   | Encoded Request |              |           |   |Plain Req | |
         |-->|   Headers #1    |------------->|           |-->|Headers #1| |
         |   +--+-----------+--+              |           |   +----------+ |
         |   +--+-----------+--+              |           |   <b>+----------+</b> |
         |   | Encoded Request |              |           |   <b>| Bad Req  |</b> |
         |-->|   Headers #2    |<b>------\       </b>|           |--><b>|Headers #3|</b> |
code (A1)|   +--+-----------+--+<b>   ----\-----></b>|Decode (A2)|   <b>+----------+</b> |
Context  |   +--+-----------+--+<b>  /     \     </b>|  Context  |   +----------+ |
         |   | Encoded Request |<b>-/       \    </b>|           |   |Bad Req   | |
         |-->|   Headers #3    |<b>          ---></b>|           |-->|Headers #2| |
         |   +--+-----------+--+              |           |   +----------+ |
         |   +--+-----------+--+              |           |   +----------+ |
         |   | Encoded Request |              |           |   |Plain Req | |
         |-->|   Headers #4    |------------->|           |-->|Headers #4| |
---------+   +--+-----------+--+              +-----------+   +----------+ |
                |           |                                              |
---------+   +--+-----------+--+              +-----------+   +----------+ |
code (B2)|   |Encoded Response |              |Encode (B1)|   |Plain Resp| |
Context  |<--|     Headers     |<-------------|  Context  |<--| Headers  | |
---------+   +--+-----------+--+              +-----------+   +----------+ |
----------------+           +----------------------------------------------+</pre>
          <aside class="notes">We'll explore this case in code!</aside>
          </section>
          <section>
            <h2>Jargon Alert!</h2>
            <p>A <b>connection</b> has multiple <b>streams</b> which can accept multiple <b>frames</b> in order</p>
          </section>
          <section>
            <h2>Handling</h2>
            <p>There are rules in the spec about how many can be "active" at a time, and what types of frames can be received when</p>
          </section>
          <section>
            <pre>
                             +--------+
                     send PP |        | recv PP
                    ,--------|  idle  |--------.
                   /         |        |         \
                  v          +--------+          v
           +----------+          |           +----------+
           |          |          | send H /  |          |
    ,------| reserved |          | recv H    | reserved |------.
    |      | (local)  |          |           | (remote) |      |
    |      +----------+          v           +----------+      |
    |          |             +--------+             |          |
    |          |     recv ES |        | send ES     |          |
    |   send H |     ,-------|  open  |-------.     | recv H   |
    |          |    /        |        |        \    |          |
    |          v   v         +--------+         v   v          |
    |      +----------+          |           +----------+      |
    |      |   half   |          |           |   half   |      |
    |      |  closed  |          | send R /  |  closed  |      |
    |      | (remote) |          | recv R    | (local)  |      |
    |      +----------+          |           +----------+      |
    |           |                |                 |           |
    |           | send ES /      |       recv ES / |           |
    |           | send R /       v        send R / |           |
    |           | recv R     +--------+   recv R   |           |
    | send R /  `----------->|        |&lt;-----------'  send R / |
    | recv R                 | closed |               recv R   |
    `----------------------->|        |&lt;----------------------'
                             +--------+
            </pre>
          <aside class="notes">
            Don't get your hopes up to high. I got excited too when I thought it was an FSM at first
          </aside>
          </section>
        </section>

        <!-- Frames -->
        <section>
          <section>
            <h2>Frames</h2>
            <pre>
    +-----------------------------------------------+
    |                 Length (24)                   |
    +---------------+---------------+---------------+
    |   Type (8)    |   Flags (8)   |
    +-+-------------+---------------+-------------------------------+
    |R|                 Stream Identifier (31)                      |
    +=+=============================================================+
    |                   Frame Payload (0...)                      ...
    +---------------------------------------------------------------+
            </pre>
          </section>
          <section>
            <h2>Type</h2>
            <p>One of 10 frame types. Each has rules for payload sizes, payload content and which flags can be set.</p>
          </section>
          <section>
            <h2>Flags</h2>
            <p>A few control bits that have different uses for different frame types</p>
          </section>
          <section>
            <h2>R</h2>
            <p>A shoutout to pirates</p>
          </section>
          <section>
            <h2>Stream Identifier</h2>
            <p>Which multiplexed stream this frame is for</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Frame Types</h2>
          </section>
          <section>
            <h2>DATA</h2>
            <p>Request and Response Bodies are made of these</p>
          </section>
          <section>
            <h2>HEADERS</h2>
            <p>Request and Response Headers start with these</p>
          </section>
          <section>
            <h2>PRIORITY</h2>
            <p>Sent to change a stream's priority</p>
          </section>
          <section>
            <h2>RST_STREAM</h2>
            <p>Sent to give up on a stream</p>
          </section>
          <section>
            <h2>SETTINGS</h2>
            <p>Negotiates overall connection settings</p>
          </section>
          <section>
            <h2>PUSH_PROMISE</h2>
            <p>Headers for a response for which there was no request</p>
          </section>
          <section>
            <h2>PING</h2>
            <p>measuring round trip</p>
          </section>
          <section>
            <h2>GOAWAY</h2>
            <p>We're done here. Could be an error, could just be natual causes</p>
          </section>
          <section>
            <h2>WINDOW_UPDATE</h2>
            <p>Issues a credit for flow control</p>
          </section>
          <section>
            <h2>CONTINUATION</h2>
            <p>PUSH_PROMISE and HEADERS are the first frame of headers, but if they're too big to fit in one frame, the rest comes over in CONTINUATION frames. When a frame comes over with the END_HEADERS flag set, we know it's over</p>
          </section>
        </section>


        <section>
          <section>
            <h2>Flow Control</h2>
          </section>

          <section>
            <h2>Only Applies to Data Frames</h2>
          </section>

          <section>
            <h2>Receiver</h2>
            <p>Each receiver advertizes how many bytes it can receive</p>
          </section>

          <section>
            <h2>Sender</h2>
            <p>Won't send more than the receiver advertizes</p>
          </section>

          <section>
            <h2>WINDOW_UPDATE</h2>
            <p>The window update frame is sent by the receiver to increase the number of bytes advertized. There is no decrement operation.</p>
          </section>

          <section>
            <h2>Connection and Streams</h2>
            <p>There's a limit advertized to both</p>
          </section>
        </section>

        <section>
          <h2>Prioritization</h2>
          <p>A client can request that a server prioritizes a certain stream over another.</p>
          <p>It is built in a tree structure so you can create requests for stream dependencies.</p>
          <p>Leaves in a tree can have different weights</p>
          <h4>A server is under no obligation to honor these requests</h4>
          <aside class="notes">
            So I punted on it for V1; however, we didn't spawn each stream into it's own gen_fsm explicity so we could have control over priority in a future version.
          </aside>
        </section>

        <section>
          <section>
            <h2>Server Push</h2>
          </section>
          <section>
            <h2>Guessing about requests that will come</h2>
          </section>
          <section>
            <h2>Static Content</h2>
            <p>Imagine inspecting HTML on the way out, and sending pushes for all the CSS, JavaScript, and Images you need.</p>
            <p>Is this exciting for APIs? <b>Maybe!</b></p>
            <aside class="notes">
              If your API has common use cases, you could push expected responses. e.g. you just did GET /shoppingcart, and you might usually see a GET /item for each item in the cart after that. While currently you might just return all that info in GET /shoppingcart, you might also take advantage of PP. You might not. This might be dumb.
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h2>Upgrading HTTP1 Requests</h2>
          </section>
          <section>
            <h2>https://</h2>
            <p>Uses TLS's "Next Protocol Negotiation"</p>
            <p>Or TLS's "Application Layer Protocol Negotiation"</p>
          </section>
          <section>
            <h2>http://</h2>
            <p>Uses "Upgrade: " header.</p>
            <p>HTTP/2 servers respond with status code </p>
            <pre>101 Switching</pre>
          </section>
        </section>

        <section>
          <h2>OMG Can I See Some Erlang Already?!</h2>
          <aside class="notes">Understanding the protocol is the hardest part. Anyone can pattern match :D</aside>
        </section>

        <section>
          <h2>Chatterbox</h2>
          <p><a href="http://github.com/joedevivo/chatterbox">Chatterbox</a></p>
        </section>


        <section>
          <h2>Chatterbox FSM</h2>
          <h4>A Connection State Machine</h4>
        </section>
        <section>
          <section>
            <h2>SETTINGS</h2>
            <ul>
              <li>SETTINGS_HEADER_TABLE_SIZE</li>
              <li>SETTINGS_ENABLE_PUSH</li>
              <li>SETTINGS_MAX_CONCURRENT_STREAMS</li>
              <li>SETTINGS_INITIAL_WINDOW_SIZE</li>
              <li>SETTINGS_MAX_FRAME_SIZE</li>
              <li>SETTINGS_MAX_HEADER_LIST_SIZE</li>
            </ul>
            <aside class="notes">
              TODO: What are these?
            </aside>
          </section>

          <section>
            <h2>RFC 7540 - <a href="http://tools.ietf.org/html/rfc7540#section-3.5">Section 3.5</a></h2>
            <pre>
The client connection preface starts with a sequence of 24 octets,
which in hex notation is:
     0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
That is, the connection preface starts with the string
     "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
This sequence MUST be followed by a SETTINGS frame
(Section 6.5), which MAY be empty.
            </pre>
          </section>

          <section>
            <h2>RFC 7540 - <a href="http://tools.ietf.org/html/rfc7540#section-3.5">Section 3.5</a></h2>
            <pre>
The server connection preface consists of a potentially empty
SETTINGS frame (Section 6.5) that MUST be the first frame the server
sends in the HTTP/2 connection.

The SETTINGS frames received from a peer as part of the connection
preface MUST be acknowledged (see Section 6.5.3) after sending the
connection preface.
            </pre>
          </section>
          <section>
            <h2>RFC 7540 - <a href="http://tools.ietf.org/html/rfc7540#section-6.5.3">Section 6.5.3</a></h2>
            <pre>
Once all values have been processed, the
recipient MUST immediately emit a SETTINGS frame with the ACK flag
set.  Upon receiving a SETTINGS frame with the ACK flag set, the
sender of the altered parameters can rely on the setting having been
applied.
If the sender of a SETTINGS frame does not receive an acknowledgement
within a reasonable amount of time, it MAY issue a connection error
(Section 5.4.1) of type SETTINGS_TIMEOUT.
            </pre>
          </section>
          <section>
            <h2>RFC 7540 - <a href="http://tools.ietf.org/html/rfc7540#section-4">Section 4</a></h2>
            <pre>
Once the HTTP/2 connection is established, endpoints can begin
exchanging frames.
            </pre>
            <aside class="notes">Pity party: see how many sections and out of order things I had to find for this piece of flow?</aside>
          </section>
          <section>
<pre><code data-trim contenteditable class="erlang">
-define(PREAMBLE, "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n").

handle_info({_, _Socket, &lt;&lt;?PREAMBLE,Bin/bits&gt;&gt;}, _, S) ->
    lager:debug("handle_info HTTP/2 Preamble!"),
    gen_fsm:send_event(self(), {start_frame,Bin}),
    {next_state, settings_handshake, S};
</code></pre>
          </section>

          <section>
            <h2>Settings Handshake State</h2>
          </section>

          <section>
            <h2>What it does it</h2>
            <ol>
              <li>Send our server SETTINGS frame</li>
              <li>Wait for client SETTINGS frame</li>
              <li>Wait client's SETTINGS ACK</li>
              <li>Send ACK of client settings</li>
              <li>Backlog any frames before 3 and 4 are done</li>
              <li>Transition to connected state</li>
            </ol>
          </section>

          <section>
<pre><code data-trim contenteditable class="erlang">
settings_handshake({start_frame, Bin}, S=#chatterbox_fsm_state{...}) ->
    NewState = case Bin of
        <<>> ->
            S;
        _ ->
            OtherFrames = http2_frame:from_binary(Bin),
            {SettingsBacklog, FB} = lists:partition(
                fun({X,_}) -> X#frame_header.type =:= ?SETTINGS end,
                OtherFrames),
            S#chatterbox_fsm_state{frame_backlog=FB, settings_backlog=SettingsBacklog}
    end,

    %% Assemble our settings and send them
    http2_frame_settings:send(Socket, ServerSettings),
    settings_handshake_loop(NewState, {false, false}).
</code></pre>
            <aside class="notes">When we start, read all the frames we can and split them into ?SETTINGS and other</aside>
          </section>

          <section>
<pre><code data-trim contenteditable class="erlang">
settings_handshake_loop(State=#chatterbox_fsm_state{frame_backlog=FB}, {true, true}) ->
    gen_fsm:send_event(self(), backlog),
    {next_state, connected, State#chatterbox_fsm_state{frame_backlog=lists:reverse(FB)}};
settings_handshake_loop(State = #chatterbox_fsm_state{
                                   settings_backlog=[{H,P}|T]
                                  },
                        Acc) ->
    lager:debug("[settings_handshake] Backlogged Frame"),
    settings_handshake_loop({H#frame_header.type, ?IS_FLAG(H#frame_header.flags, ?FLAG_ACK)},
                            {H, P},
                            Acc,
                            State#chatterbox_fsm_state{settings_backlog=T});
settings_handshake_loop(State = #chatterbox_fsm_state{
                                   connection=#connection_state{
                                                 socket=Socket
                                                },
                                   settings_backlog=[]
                                  },
                        Acc) ->
    lager:debug("[settings_handshake] Incoming Frame"),
    {H, Payload} = http2_frame:read(Socket),
    settings_handshake_loop(
      {H#frame_header.type,?IS_FLAG(H#frame_header.flags, ?FLAG_ACK)},
      {H, Payload},
      Acc,
      State).
</code></pre>
            <aside class="notes">This here is just to read frames off the backlog (from before we sent our settings frame) in case the client settings already came in, otherwise it starts reading frames off the socket</aside>
          </section>

          <section>
<pre><code data-trim contenteditable class="erlang">
settings_handshake_loop({?SETTINGS,false},{_Header,CSettings}, {ReceivedAck,false},
                        State = #chatterbox_fsm_state{connection=C=#connection_state{socket=S}}) ->
    ClientSettings = http2_frame_settings:overlay(#settings{}, CSettings),
    lager:debug(
      "[settings_handshake] got client_settings: ~p",
      [http2_frame_settings:format(ClientSettings)]),
    http2_frame_settings:ack(S),
    settings_handshake_loop(
      State#chatterbox_fsm_state{
        connection=C#connection_state{
                     send_settings=ClientSettings
                    }
       },
      {ReceivedAck,true}
     );
settings_handshake_loop({?SETTINGS,true},{_,_},{false,ReceivedClientSettings},State) ->
    lager:debug("[settings_handshake] got server_settings ack"),
    settings_handshake_loop(State,{true,ReceivedClientSettings});
settings_handshake_loop(_,FrameToBacklog,Acc,State=#chatterbox_fsm_state{frame_backlog=FB}) ->
    lager:debug("[settings_handshake] got rando frame"),
    settings_handshake_loop(State#chatterbox_fsm_state{frame_backlog=[FrameToBacklog|FB]}, Acc).
</code></pre>
            <aside class="notes">And here we check for settings frame with client settings, settings frame with ACK or other</aside>
          </section>

          <section>
            <h2>Connected State</h2>
          </section>
        </section>

        <section>
          <section>
            <h2>Development</h2>
          </section>
          <section>
            <h2>Minimum Viable Response: NGHTTP2</h2>
            <p>No content handler, just a hard coded response</p>
          </section>
          <section>
            <h2>Firefox 37</h2>
            <p>This Slide Deck!</p>
          </section>
          <section>
            <h2>When Things Go Wrong</h2>
            <p>Building a client that breaks the rules</p>
          </section>
          <section>
            <h2>http2c APIs</h2>
            <ul>
              <li>High Level - Request/Response</li>
              <li>Mid Level - HTTP/2 Frames</li>
              <li>Low Level - Binary</li>
            </ul>
          </section>
          <section>
            <p>I needed a client that could break the rules, so I could test that the server breaks properly</p>
          </section>
          <section>
            <p>RFC 7540 <a href="http://tools.ietf.org/html/rfc7540#section-4.3">Section 4.3</a></p>
<pre>
Each header block is processed as a discrete unit.  Header blocks
MUST be transmitted as a contiguous sequence of frames, with no
interleaved frames of any other type or from any other stream.  The
last frame in a sequence of HEADERS or CONTINUATION frames has the
END_HEADERS flag set.  The last frame in a sequence of PUSH_PROMISE
or CONTINUATION frames has the END_HEADERS flag set.  This allows a
header block to be logically equivalent to a single frame.
</pre>
            <p>RFC 7540 <a href="http://tools.ietf.org/html/rfc7540#section-6.2">Section 6.2</a></p>
<pre>
END_HEADERS (0x4):  When set, bit 2 indicates that this frame
  contains an entire header block (Section 4.3) and is not followed
  by any CONTINUATION frames.

A HEADERS frame without the END_HEADERS flag set MUST be followed
by a CONTINUATION frame for the same stream.  A receiver MUST
treat the receipt of any other type of frame or a frame on a
different stream as a connection error (Section 5.4.1) of type
PROTOCOL_ERROR.
</pre>
          </section>
          <section>
<pre><code data-trim contenteditable class="erlang">
Frames = [
   {#frame_header{length=8,type=?HEADERS,stream_id=3},
    #headers{ block_fragment=H1 }},
   {#frame_header{length=8,type=?CONTINUATION,stream_id=3},
    #continuation{block_fragment=H2}},
   %% not allowed!
   {#frame_header{length=8,type=?HEADERS,stream_id=3},
    #headers{block_fragment=H1}},
   {#frame_header{
     length=8,type=?CONTINUATION,
     flags=?FLAG_END_HEADERS,
     stream_id=3
     },
    #continuation{block_fragment=H3}}
],
http2c:send_unaltered_frames(Client, Frames),
</code></pre>
          </section>

          <section>
<pre><code data-trim contenteditable class="erlang">
%% No response on stream 3
Resp = http2c:get_frames(Client, 3),
?assertEqual(0, length(Resp)),

%% One GOAWAY frame on stream 0
Resp2 = http2c:get_frames(Client, 0),
1 = length(Resp2),

%% Protocol Error
[{_GoAwayH, GoAway}] = Resp2,
?PROTOCOL_ERROR = GoAway#goaway.error_code,
</code></pre>
          </section>

          <section>
            <h2>chatterbox_fsm: continuation state</h2>
            <ul>
              <li>Any time a HEADERS frame is received, enter CONTINUATION state</li>
              <li>In that state, only accept CONTINUATION frames from that stream</li>
              <li>when a CONTINUATION with the END HEADERS flag is set, transition back to 'connected'</li>
              <li>If any other frame type comes in (or CONTINUATION with other stream id), send GOAWAY with CONNECTION ERROR</li>
            </ul>
          </section>
          <section>
<pre><code data-trim contenteditable class="erlang">
continuation(start_frame, #chatterbox_fsm_state{}) ->
    Frame = {FH,_} = http2_frame:read(Socket),
    Response = case FH#frame_header.type of
       ?CONTINUATION ->
           route_frame(Frame, S);
       _ ->
           go_error(?PROTOCOL_ERROR, S)
    end,
    gen_fsm:send_event(self(), start_frame),
    Response;
continuation(_, State) ->
    go_error(?PROTOCOL_ERROR, State).
</code></pre>
          </section>
          <section>
            <h2>Take out the bad frame</h2>
<pre><code data-trim contenteditable class="erlang">
    Resp = http2c:get_frames(Client, 3),
    ct:pal("Resp: ~p", [Resp]),
    ?assertEqual(2, length(Resp)).
</code></pre>
          <aside class="notes">If I took out the bad frame, which I did for another test, I'd assert this instead</aside>
        </section>

        <section>
          <section>
            <h2>chatterbox_fsm</h2>
            <p>Routing frames in the connected state</p>
          </section>

          <section>
<pre><code data-trim contenteditable class="erlang">
-spec route_frame(frame(), #chatterbox_fsm_state{}) -&gt;
    {next_state, connected, #chatterbox_fsm_state{}}.
</code></pre>
          </section>
          <section>
            <h2>FRAMES</h2>
            <p>The http2_frame module</p>
          </section>

          <section>
<pre><code data-trim contenteditable class="erlang">
-spec from_binary(binary()) -&gt; [{frame_header(), payload()}].
from_binary(Bin) -&gt;
    from_binary(Bin, []).

from_binary(&lt;&lt;&gt;&gt;, Acc) -&gt;
    Acc;
from_binary(Bin, Acc) -&gt;
    {Header, PayloadBin} = read_binary_frame_header(Bin),
    {ok, Payload, Rem} = read_binary_payload(PayloadBin, Header),
    from_binary(Rem, [{Header, Payload}|Acc]).
</code></pre>
            <aside class="notes">
              The binary passed in can be more than one frame. I haven't handled the case where a partial frame arrives. I've started that work in the client, so... soon?
            </aside>
          </section>

          <section>
            <h2>The Front 9</h2>
          </section>

          <section>
<pre>
        +-----------------------------------------------+
        |                 Length (24)                   |
        +---------------+---------------+---------------+
        |   Type (8)    |   Flags (8)   |
        +-+-------------+---------------+-------------------------------+
        |R|                 Stream Identifier (31)                      |
        +=+=============================================================+
        |                   Frame Payload (0...)                      ...
        +---------------------------------------------------------------+
  </pre>
<pre><code data-trim contenteditable class="erlang">
-spec read_binary_frame_header(binary()) -&gt; {frame_header(), binary()}.
read_binary_frame_header(&lt;&lt;Length:24,Type:8,Flags:8,_R:1,StreamId:31,Rem/bits&gt;&gt;) -&gt;
    Header = #frame_header{
        length = Length,
        type = Type,
        flags = Flags,
        stream_id = StreamId
    },
    {Header, Rem}.
</code></pre>
            <aside class="notes">The first 9 bytes better be a frame header. The following bytes depend on it.</aside>
          </section>

          <section>
            <h2>The Following Bytes</h2>
            <p>http2_frame behaviour</p>
<pre><code data-trim contenteditable class="erlang">
-callback read_binary(Bin::binary(),
                      Header::frame_header()) -&gt;
    {ok, payload(), Remainder::binary()} | {error, term()}.
-callback to_binary(payload()) -&gt; iodata().
</code></pre>
            <aside class="notes">
              These callbacks are for deserialzing payloads of specific frame types
            </aside>
          </section>

          <section>
<pre><code data-trim contenteditable class="erlang">
-spec read_binary_payload(binary(), frame_header()) -&gt;
    {ok, payload(), binary()} | {error, term()}.
read_binary_payload(Bin, Header = #frame_header{type=?DATA}) -&gt;
    http2_frame_data:read_binary(Bin, Header);
read_binary_payload(Socket, Header = #frame_header{type=?HEADERS}) -&gt;
    http2_frame_headers:read_binary(Socket, Header);
%% etc...
</code></pre>
            <aside class="notes"></aside>
          </section>


          <section>
            <h2>chatterbox_fsm</h2>
          </section>
          <section>
<pre><code data-trim contenteditable class="erlang">
-spec route_frame(frame(), #chatterbox_fsm_state{}) -&gt;
    {next_state, connected, #chatterbox_fsm_state{}}.
</code></pre>
          </section>
          <section>
            <h2>FRAME_SIZE_ERROR</h2>
          </section>
          <section>
            <h4>connection level processing</h4>
<pre><code data-trim contenteditable class="erlang">
route_frame({#frame_header{length=L}, _},
            S = #chatterbox_fsm_state{
                   connection=#connection_state{
                                 recv_settings=#settings{max_frame_size=MFS}
                                }})
    when L &gt; MFS -&gt;
    go_error(?FRAME_SIZE_ERROR, S);
</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h2>STREAMS</h2>
          </section>
          <section>
            <h2>http2_stream</h2>
            <p>A Faux-nite State Machine</p>
          </section>
          <section>
            <pre>
                             +--------+
                     send PP |        | recv PP
                    ,--------|  idle  |--------.
                   /         |        |         \
                  v          +--------+          v
           +----------+          |           +----------+
           |          |          | send H /  |          |
    ,------| reserved |          | recv H    | reserved |------.
    |      | (local)  |          |           | (remote) |      |
    |      +----------+          v           +----------+      |
    |          |             +--------+             |          |
    |          |     recv ES |        | send ES     |          |
    |   send H |     ,-------|  open  |-------.     | recv H   |
    |          |    /        |        |        \    |          |
    |          v   v         +--------+         v   v          |
    |      +----------+          |           +----------+      |
    |      |   half   |          |           |   half   |      |
    |      |  closed  |          | send R /  |  closed  |      |
    |      | (remote) |          | recv R    | (local)  |      |
    |      +----------+          |           +----------+      |
    |           |                |                 |           |
    |           | send ES /      |       recv ES / |           |
    |           | send R /       v        send R / |           |
    |           | recv R     +--------+   recv R   |           |
    | send R /  `----------->|        |&lt;-----------'  send R / |
    | recv R                 | closed |               recv R   |
    `----------------------->|        |&lt;----------------------'
                             +--------+
            </pre>
          </section>
          <section>
            <h2>Stream State</h2>
<pre><code data-trim contenteditable class="erlang">
-record(stream_state, {
  stream_id = undefined :: stream_id(),
  state = idle :: stream_state_name(),
  send_window_size = ?DEFAULT_INITIAL_WINDOW_SIZE :: integer(),
  recv_window_size = ?DEFAULT_INITIAL_WINDOW_SIZE :: integer(),
  queued_frames = [] :: [frame()],
  incoming_frames = [] :: [frame()]
}).
</code></pre>
          </section>

          <section>
            <h2>Stream Transitions</h2>
<pre><code data-trim contenteditable class="erlang">
-spec recv_frame(frame(), stream_state()) -> stream_state().
</code></pre>
          </section>

          <section>
            <h2>Stream Transitions</h2>
<pre><code data-trim contenteditable class="erlang">
route_frame(F={H=#frame_header{
                  length=L,
                  stream_id=StreamId}, _Payload},
            S = #chatterbox_fsm_state{
                   streams=Streams,
                   connection=C=#connection_state{
                                   socket=_Socket,
                                   recv_window_size=RWS
                                  }
                  })
    when H#frame_header.type == ?DATA ->
    {Stream, NewStreamsTail} = get_stream(StreamId, Streams),

    %% Decrement connection recv_window L
    NewRWS = RWS - L,

    %% Decrement stream recv_window L happens in http2_stream:recv_frame
    FinalStream = http2_stream:recv_frame(F, Stream),

    {next_state, connected, S#chatterbox_fsm_state{
                              streams=[{StreamId,FinalStream}|NewStreamsTail],
                              connection=C#connection_state{
                                           recv_window_size=NewRWS
                                          }
                             }
    };
</code></pre>
            <aside class="notes">This is just the handler for data frames coming in on the chatterbox_fsm connection level</aside>
          </section>
          <section>
<pre><code data-trim contenteditable class="erlang">
FinalStream = http2_stream:recv_frame(F, Stream),
</code></pre>
            <aside class="notes">If you take one line away from the last slide, let it be this one, because it sends you...</aside>
          </section>
          <section>
            <h2>http2_stream</h2>
            <p>State Machine without a Process</p>
          </section>
          <section>
            <h2>new/2</h2>
            <p>new/2 is the new init/1</p>
            <pre><code data-trim contenteditable class="erlang">
-spec new(stream_id(), {pos_integer(), pos_integer()}) -> stream_state().
new(StreamId, {SendWindowSize, RecvWindowSize}) ->
    #stream_state{
       stream_id=StreamId,
       send_window_size = SendWindowSize,
       recv_window_size = RecvWindowSize
      }.
</code></pre>
            <aside class="notes">All of the initial state, none of the process spawning</aside>
          </section>
          <section>
<pre><code data-trim contenteditable class="erlang">
recv_frame(F={FH = #frame_header{
              stream_id=StreamId,
              type=?HEADERS
             }, _Payload},
           State = #stream_state{state=idle})
when ?IS_FLAG(FH#frame_header.flags, ?FLAG_END_STREAM) ->
    State#stream_state{
      stream_id = StreamId,
      state = half_closed_remote,
      incoming_frames = [F]
     };
</code></pre>
            <aside class="notes">First clause will handle transitions from idle to half_closed_remote, via HEADERS frame with END_STREAM flag set</aside>
          </section>
          <section>
            <h2>http2_stream</h2>
<pre><code data-trim contenteditable class="erlang">
recv_frame(F={_FH = #frame_header{
              stream_id=StreamId,
              type=?HEADERS
             }, _Payload},
           State = #stream_state{state=idle}) ->
    State#stream_state{
      stream_id = StreamId,
      state = open,
      incoming_frames = [F]
     };
</code></pre>
            <aside class="notes">This one goes to open, because it's a headers frame, but not the end of stream</aside>
          </section>
        </section>

        <section>
          <section>
            <h2>References</h2>
          </section>
          <section>
            <h2>HTTP History References</h2>
            <ul>
              <li><a href="http://http2.github.io/faq/">HTTP/2 Official FAQ</a></li>
              <li><a href="http://daniel.haxx.se/http2/">HTTP2 Explained - Daniel Stenberg</a></li>
              <li><a href="http://chimera.labs.oreilly.com/books/1230000000545/ch09.html">High Performance Browser Networking  - Ilya Grigorik</a></li>
            </ul>
          </section>
          <section>
            <h2>HTTP/1.x RFCs</h2>
            <ul>
              <li><a href="http://tools.ietf.org/html/rfc1945">RFC 1945 - HTTP/1.0</a></li>
              <li><a href="http://tools.ietf.org/html/rfc2616">RFC 2616 - HTTP/1.1</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7230">RFC 7230 - HTTP/1.1: Message Syntax and Routing</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7231">RFC 7231 - HTTP/1.1: Semantics and Content</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7232">RFC 7232 - HTTP/1.1: Conditional Requests</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7233">RFC 7233 - HTTP/1.1: Range Requests</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7234">RFC 7234 - HTTP/1.1: Caching</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7235">RFC 7235 - HTTP/1.1: Authentication</a></li>
            </ul>
          </section>
          <section>
            <h2>HTTP/2 RFCs</h2>
            <ul>
              <li><a href="http://tools.ietf.org/html/rfc7540">RFC 7540 - HTTP/2</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7541">RFC 7541 - HPACK - Header Compression for HTTP/2</a></li>
            </ul>
          </section>
        </section>

        <section>
          <h2>THANKS!</h2>
        </section>
      </div>


    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        width: 1200,
        controls: true,
        progress: true,
        history: true,
        center: true,
        slideNumber: true,
        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
