<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Chatterbox: HTTP/2 for Erlang</title>

    <meta name="description" content="An Introduction to HTTP/2 and the code that implements it">
    <meta name="author" content="Joe DeVivo">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/abba.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
  <section>
    <h1>Take a Chance<br/>on HTTP</h1>
    <h3>Chatterbox: HTTP/2 for Erlang</h3>
    <img src="./img/crown.png" style="border:0px"/>
    <p>
      <small>Joe DeVivo / <a href="http://twitter.com/joedevivo">@joedevivo</a></small>
    </p>
    <center>
      <div style="height: 3px; width:100px; background: #b89c30; align: center;"></div>
    </center>
  </section>

  <section>
    <h2>A (Hopefully) Breif History of HTTP</h2>
  </section>

  <section>
    <h2>HTTP/0.9</h2>
    <p>On the scene in 1991</p>
    <ul>
      <li>Single Line Request: GET /&lt;path&gt;</li>
      <li>Request ends on CRLF</li>
      <li>Only responds with HTML ASCII</li>
            <li>When that's done, Connection over</li>
          </ul>
          <aside class="notes">
            I would have read the spec, but I was busy being 15 and not willing to pay the $5/mo my ISP wanted for "world wide web".
            I had gopher included for free anyway!
          </aside>
        </section>

        <section>
          <p>HTTP/0.9 Is still out there!</p>
          <p>tl;dr - ask for an HTML file and you'll get one</p>
        </section>

        <section>
          <h2>HTTP/1.0</h2>
          <p>
            1996 - <a href="http://tools.ietf.org/html/rfc1945">RFC-1945: HTTP/1.0</a>
          </p>
          <p> New Features! </p>
          <ul>
            <li>HEADERS! Request and Response</li>
            <li>Response Codes</li>
            <li>Serves file types other than HTML</li>
          </ul>
        </section>

        <section>
          <h2>HTTP/1.0 Lifecycle</h2>
          <ul>
            <li>Request headers separated by CRLF</li>
            <li>2x CRLF means request is done</li>
            <li>Status Code as first line of response</li>
            <li>Response headers separated by CRLF</li>
            <li>Connection closed after every request</li>
          </ul>

          <aside class="notes">
            This is the first really real spec. I'd written HTML by this point, which I guess means I've used HTTP/0.9
            What, you didn't write HTML freshman year?
          </aside>
        </section>

        <section>
          <h2>HTTP/1.0</h2>
          <p>It really wasn't a standard</p>
          <aside class="notes">
            Kind of a reverse spec of everything that was already happening. Supporting non-HTML files took the "HT" out of "HTTP"
          </aside>
        </section>

        <section>
          <h2>HTTP/1.1</h2>
          <p>1997 - <a href="http://tools.ietf.org/html/rfc2068">RFC-2068: HTTP/1.1</a></p>
          <p>1999 - <a href="http://tools.ietf.org/html/rfc2616">RFC-2616: HTTP/1.1</a></p>
          <aside class="notes">
            HTTP/1.1 was here to resolve ambiguities in HTTP/1.0 and introduce performance optimizations
          </aside>
        </section>

        <section>
          <h2>New Features</h2>
          <ul>
            <li>Keepalive Connections</li>
            <li>Chunked Transfers</li>
            <li>Request Pipelining</li>
            <li>Byte-Range Requests</li>
            <li>Transfer Encodings</li>
            <li>Close connection with 'Connection: close' header</li>
            <li>Negotiation of: charsets, caching, language, encoding, and more</li>
          </ul>

          <aside class="notes">
            Pipelining is not without it's problems
          </aside>
        </section>

        <section>
          <section>
            <h2>HTTP/1.1 Lifecycle</h2>
            <p>More Complex</p>
          </section>
          <section>
            <h2>HTTP/1.1 Request</h2>
            <ul>
              <li>Still Plaintext</li>
              <li>Still one header per line</li>
              <li>Still 2x CRLF to terminate</li>
            </ul>
          </section>
          <section>
            <h2>HTTP/1.1 Response</h2>
            <ul>
              <li>Still starts with a response code</li>
              <li>Still has one response header per line</li>
            </ul>
          </section>
          <section>
            <h2>Possible Chuncked Response Data</h2>
          </section>
          <section>
            <h2>Connection not closed!</h2>
          </section>
          <section>
            <h2>HTTP/1.1 tl;dr</h2>
            <ul>
            <li>Request</li>
            <li>Response</li>
            <li>Repeat</li>
            </ul>
          </section>
        </section>

        <section>
          <h2>Side note on HTTP/1.0</h2>
          <p>Keepalive connections were backported to HTTP/1.0, but it's disabled by defaul</p>
        </section>

        <section>
          <section>
            <h2>On HTTP/1.1's TCP Useage</h2>
          </section>
          <section>
            <h2>It uses less connections because 'Keepalive'</h2>
            <p>That's good!</p>
          </section>
          <section>
            <h2>It sequentially sends requests and receives responses in order via Pipelining</h2>
            <p>That's bad!</p>
            <p>Well, sometimes. Be responsible</p>
          </section>
          <section>
            <h2>Head of line Blocking</h2>
            <ul>
              <li>Pipelining lets you send another request before the first one responds</li>
              <li>It will not respond until the first response is fully served</li>
              <li>Most browsers disable pipelining by default</li>
            </ul>
          </section>
        </section>

        <section>
          <h2>HTTP/1.1 Spec is HUGE</h2>
          <p>In 2014's special edition remaster, HTTP/1.1 was split into SIX RFCs totaling over 292 pages</p>
        </section>

        <section>
          <h2>Many HTTP/1.1 Features are OPTIONAL</h2>
          <p>Like Pipelining</p>
          <p>Very rare to find a single product implementing the full feature set</p>
          <aside class="notes">
            that means a lot software talking to each other, that have different feature sets
          </aside>
        </section>

        <section>
          <h2>Performance Hacks</h2>
          <ul>
            <li>Spriting</li>
            <li>Inlining</li>
            <li>Concatenation</li>
            <li>Sharding</li>
          </ul>
          <aside class="notes">
            Spriting/Inlinging - Different ways of serving a large file, and then displaying different parts in differnt places.
            Concatenation - Manually merging javascript files, so they're one file
            Sharding - Different files on different servers = more connections open
          </aside>
        </section>

        <section>
          <h2>Transfer Sizes</h2>
          <h2>Dec/2010 - Apr/2015</h2>
          <img src="./img/chart2.png"/>
          <p>Transfer sizes and quantities are going UP!</p>
        </section>

        <section>
          <h2>Goals of an HTTP Update</h2>
          <ul>
            <li>Less RTT Sensitivity</li>
            <li>Fix pipelining</li>
            <li>Discourage multiple connections</li>
            <li>Keep existing semantics</li>
          </ul>
        </section>

        <section>
          <h2>SPDY</h2>
          <p>Google tried to fix this and pretty much proved it could work</p>
        </section>

        <section>
          <h2>s/SPDY\/3/http2 draft-00</h2>
          <p>One day, the SPDY/3 draft became the HTTP/2 draft</p>
        </section>

        <section>
          <h2>HTTP/2</h2>
          <p>
            2015 - <a href="http://tools.ietf.org/html/rfc7540">RFC 7540</a>
          </p>

          <ul>
            <li>You can keep your semantics</li>
            <li>Binary Protocol</li>
            <li>Header Compression</li>
            <li>Mulitplexing</li>
            <li>Frames</li>
            <li>Flow Control</li>
            <li>Prioritization (Maybe?)</li>
            <li>Server Push</li>
            <li>Upgrading HTTP/1 requests</li>
          </ul>
        </section>

        <!-- semantics -->
        <section>
          <section>
            <h2>Keep your semantics</h2>
            <ul>
              <li>methods: GET, POST, and Friends</li>
              <li>Headers!</li>
              <li>Requests</li>
              <li>Responses</li>
              <li>if you did it before, it should still work</li>
            </ul>
          </section>
          <section>
            <h2>Technically that means</h2>
            <ul>
              <li>RFC7231: HTTP/1.1 Semantics and Content</li>
              <li>RFC7232: HTTP/1.1 Conditional Request</li>
              <li>RFC7233: HTTP/1.1 Range Requests</li>
              <li>RFC7234: HTTP/1.1 Chaching</li>
              <li>RFC7235: HTTP/1.1 Authentication</li>
              <li>And parts of RFC7230: HTTP/1.1 Mesage Syntax and Routing</li>
            </ul>
          </section>
        </section>

        <!-- binary -->
        <section>
          <section>
            <h2>Binary Protocol</h2>
            <ul>
              <li>Bye Bye Telnet</li>
              <li>Bleep blorp</li>
              <li>Binaries make the spec less ambigous</li>
            </ul>
          </section>
          <section>
            <h2>Binaries =:= Happy Erlangers</h2>
          </section>
        </section>

        <!-- hpack -->
        <section>
          <section>
            <h2>Header Compression</h2>
            <ul>
              <li>Stateless protocols are repetitive</li>
              <li>HTTP is stateless</li>
            </ul>
          </section>
          <section>
            <h2>HPACK - <a href="http://tools.ietf.org/html/rfc7541">RFC 7541</a></h2>
            <p>A whole RFC just for header compression!</p>
          </section>
          <section>
            <h2>Compression Context is Stateful</h2>
            <p>
              By having a stateful context for compression, you can send the same header 100 times over a connection, but after the first time the client and server will have agreed on a much smaller binary value.
            </p>
          </section>
          <section>
            <h2>There Are Two Contexts</h2>
            <p>One for each peer</p>
            <p>Maybe easier to think of as one for Requests and one for Responses</p>
          </section>
          <section>
            <h2>The Static Table</h2>
<pre>
+-------+-----------------------------+---------------+
| Index | Header Name                 | Header Value  |
+-------+-----------------------------+---------------+
| 1     | :authority                  |               |
| 2     | :method                     | GET           |
| 3     | :method                     | POST          |
| 4     | :path                       | /             |
| 5     | :path                       | /index.html   |
| 6     | :scheme                     | http          |
| 7     | :scheme                     | https         |
| 8     | :status                     | 200           |
| 9     | :status                     | 204           |
| 10    | :status                     | 206           |
| 11    | :status                     | 304           |
| 12    | :status                     | 400           |
| 13    | :status                     | 404           |
| 14    | :status                     | 500           |
| 15    | accept-charset              |               |
| 16    | accept-encoding             | gzip, deflate |
                    ...
</pre>
            <aside class="notes">
              These are for really common headers. e.g. A response code of 200 is just going to be represented by "8".
              Sometimes there's no value, but the header name is what we're saving here, so 15+value is always "accept-charset"
            </aside>
          </section>
          <section>
            <ul>
              <li>Indexes 1-61</li>
              <li>Sometimes value, sometimes not</li>
            </ul>
          </section>
          <section>
            <h2>The Dynamic Table</h2>
            <p>Indexes 62+</p>
          </section>
          <section>
            <p>
              Bounded by size in HTTP/2 connection settings as a security precaution
            </p>
          </section>
          <section>
            <h2>How "H" Packs</h2>
          </section>
          <section>
            <h2>Data Types</h2>
            <ul>
              <li>Numbers</li>
              <li>Strings</li>
            </ul>
          </section>
          <section>
            <h2>Indexed Header Field</h2>
            <pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 |        Index (7+)         |
+---+---------------------------+
            </pre>
            <aside class="notes">
              A Name/Value pair already in the table
            </aside>
          </section>

          <section>
            <h2>Literal Header Field w/ Index</h2>
            <pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 |      Index (6+)       |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
            </pre>
            <aside class="notes">
              A Name that's already in the table, but a different value
            </aside>
          </section>

          <section>
            <h2>Literal Header Field w/ Index</h2>
            <pre>
   0   1   2   3   4   5   6   7
 +---+---+---+---+---+---+---+---+
 | 0 | 1 |           0           |
 +---+---+-----------------------+
 | H |     Name Length (7+)      |
 +---+---------------------------+
 |  Name String (Length octets)  |
 +---+---------------------------+
 | H |     Value Length (7+)     |
 +---+---------------------------+
 | Value String (Length octets)  |
 +-------------------------------+
            </pre>
            <aside class="notes">
              Neither the name nor value are in the table
            </aside>
          </section>

          <section>
            <h2>Types of Literal Fields</h2>
            <ul>
              <li>with Indexing - added to the dynamic table</li>
              <li>without Indexing - not added to the DT</li>
              <li>never Indexed - never added to any DT</li>
            </ul>
            <aside class="notes">
              All three are ways of saying the same thing, as far as "here's a header and value, but some are not compressed. "never" means no proxies can compress it either, while "without" applies to just one hop.
            </aside>
          </section>

          <section>
            <h2>Huffman Encoding</h2>
            <ul>
              <li>Designed for HTTP</li>
              <li>The more common the ASCII character, the fewer bytes it takes</li>
            </ul>
            <aside class="notes">Did you see that "H" bit?</aside>
          </section>
          <section>
<pre>
                                                        code
                          code as bits                 as hex   len
        sym              aligned to MSB                aligned   in
                                                       to LSB   bits
       (  0)  |11111111|11000                             1ff8  [13]
       (  1)  |11111111|11111111|1011000                7fffd8  [23]
       (  2)  |11111111|11111111|11111110|0010         fffffe2  [28]
       (  3)  |11111111|11111111|11111110|0011         fffffe3  [28]
       (  4)  |11111111|11111111|11111110|0100         fffffe4  [28]
                               ...
   '0' ( 48)  |00000                                         0  [ 5]
   '1' ( 49)  |00001                                         1  [ 5]
   '2' ( 50)  |00010                                         2  [ 5]
   '3' ( 51)  |011001                                       19  [ 6]
   '4' ( 52)  |011010                                       1a  [ 6]
                               ...
   'X' ( 88)  |11111100                                     fc  [ 8]
   'Y' ( 89)  |1110011                                      73  [ 7]
   'Z' ( 90)  |11111101                                     fd  [ 8]
   '[' ( 91)  |11111111|11011                             1ffb  [13]
   '\' ( 92)  |11111111|11111110|000                     7fff0  [19]
   ']' ( 93)  |11111111|11100                             1ffc  [13]
   '^' ( 94)  |11111111|111100                            3ffc  [14]
   '_' ( 95)  |100010                                       22  [ 6]
   '`' ( 96)  |11111111|1111101                           7ffd  [15]
   'a' ( 97)  |00011                                         3  [ 5]
   'b' ( 98)  |100011                                       23  [ 6]
   'c' ( 99)  |00100                                         4  [ 5]
   'd' (100)  |100100                                       24  [ 6]
   'e' (101)  |00101                                         5  [ 5]
</pre>
          </section>
          <section>
            <p>
              See?! Weird things like "non visualizable ASCII code 3" are 28 bits, but useful things like "1" are 5 bits. We're all about optimizing the wire
            </p>
          </section>
          <section>
            <h2>Examples</h2>
            <p>
              There are tons of cool examples in <a href="http://tools.ietf.org/html/rfc7541#appendix-C">HPACK: Appendix C</a>. They're so good that I turned them into <a href="https://github.com/joedevivo/chatterbox/blob/master/test/hpack_tests.erl#L60">EUnit tests</a>
            </p>
          </section>
        </section>

        <!-- HPACK Example -->
        <section>
          <section>
            <h2>HPACK Tables Example</h2>
          </section>
          <section>
            <h2>Request 1</h2>
            <pre>
:path - "/"
user-agent - "my cool browser"
x-custom-header - "some custom value"
            </pre>
          </section>
          <section>
<pre>
:path - "/"  - Index 4
user-agent - "my cool browser" - Index 58, Literal Value "my cool browser"
x-custom-header - "some custom value" - Non indexed "x-custom-header", "some custom value"
</pre>
          </section>
          <section>
            <h2>R1 Context updates</h2>
            <ul>
              <li>:path changes nothing</li>
              <li>"user-agent"/"my cool browser" is now Index 62</li>
              <li>"x-custom-header"/"some custom value" is now Index 62
              <li>"user-agent"/"my cool browser" is +1'd to 63</li>
            </ul>
          </section>

          <section>
            <h2>Request 2</h2>
            <pre>
:path - "/some_file.html"
user-agent - "my cool browser"
x-custom-header - "some custom value"
            </pre>
          </section>
          <section>
<pre>
:path - "/some_file.html"  - Index 4, Literal Value "/some_file.html"
user-agent - "my cool browser" - Index 63
x-custom-header - "some custom value" - Index 62
</pre>
          </section>
          <section>
            <h2>R2: Context updates</h2>
            <ul>
              <li>":path"/"/some_file.html" is the new Index 62</li>
              <li>"x-custom-header"/"some custom value" is +1'd 63</li>
              <li>"user-agent"/"my cool browser" is +1'd to 64</li>
            </ul>
            <aside class="notes">
              Basically an MRU cache. LRU headers fall off the end of the table
            </aside>
          </section>
          <section>
            <h2>Request 3</h2>
            <pre>
:path - "/some_file.html"
user-agent - "my cool browser"
x-custom-header - "new value"
            </pre>
          </section>
          <section>
<pre>
:path - "/some_file.html"  - Index 62
user-agent - "my cool browser" - Index 64
x-custom-header - "new value" - Index 63, Literal Value "new value"
</pre>
          </section>
          <section>
            <h2>R: Context updates</h2>
            <ul>
              <li>"x-custom-header"/"new value" is the new 62</li>
              <li>":path"/"/some_file.html" is +1'd to 63</li>
              <li>"user-agent"/"my cool browser" is +1'd to 64</li>
              <li>"x-custom-header"/"some custom value" is +1'd 65</li>
            </ul>
            <aside="notes">
              when the sum of the sizes of name/value pairs exceedes the maximum table size, that last header falls off the end. bye!
            </aside>
          </section>
        </section>

        <!-- Multiplexing -->
        <section>
          <section>
            <h2>Multiplexing: Pipelining done right</h2>
          </section>
          <section>
            <h2>Streams</h2>
            <p>There's one connection, streams are logical abstractions across it</p>
          </section>
          <section>
            <h2>Frames</h2>
            <p>A frame's stream identifier determines which multiplexed stream it belongs to</p>
          </section>
          <section>
            <h2>One Stream Id</h2>
            <h2>per frame</h2>
            <p>A series of frames for each stream id is reconstructed on the other side, in the order they arrive</p>
          </section>
          <section>
            <h2>Order?</h2>
            <p>Yes, because the header context is a piece of state, all those HPACK indexes would get out of sync if the client and server processed things in a different order</p>
          </section>
          <section>
            <h2>Handling</h2>
            <p>There are rules in the spec about how many can be "active" at a time, and what types of frames can be received when</p>
          </section>
          <section>
            <pre>
                             +--------+
                     send PP |        | recv PP
                    ,--------|  idle  |--------.
                   /         |        |         \
                  v          +--------+          v
           +----------+          |           +----------+
           |          |          | send H /  |          |
    ,------| reserved |          | recv H    | reserved |------.
    |      | (local)  |          |           | (remote) |      |
    |      +----------+          v           +----------+      |
    |          |             +--------+             |          |
    |          |     recv ES |        | send ES     |          |
    |   send H |     ,-------|  open  |-------.     | recv H   |
    |          |    /        |        |        \    |          |
    |          v   v         +--------+         v   v          |
    |      +----------+          |           +----------+      |
    |      |   half   |          |           |   half   |      |
    |      |  closed  |          | send R /  |  closed  |      |
    |      | (remote) |          | recv R    | (local)  |      |
    |      +----------+          |           +----------+      |
    |           |                |                 |           |
    |           | send ES /      |       recv ES / |           |
    |           | send R /       v        send R / |           |
    |           | recv R     +--------+   recv R   |           |
    | send R /  `----------->|        |&lt;-----------'  send R / |
    | recv R                 | closed |               recv R   |
    `----------------------->|        |&lt;----------------------'
                             +--------+
            </pre>
          <aside class="notes">
            Don't get your hopes up to high. I got excited too when I thought it was an FSM at first
          </aside>
          </section>
        </section>

        <!-- Frames -->
        <section>
          <section>
            <h2>Frames</h2>
            <pre>
+-----------------------------------------------+
|                 Length (24)                   |
+---------------+---------------+---------------+
|   Type (8)    |   Flags (8)   |
+-+-------------+---------------+-------------------------------+
|R|                 Stream Identifier (31)                      |
+=+=============================================================+
|                   Frame Payload (0...)                      ...
+---------------------------------------------------------------+
            </pre>
          </section>
          <section>
            <h2>Type</h2>
            <p>One of 10 frame types. Each has rules for payload sizes, payload content and which flags can be set.</p>
          </section>
          <section>
            <h2>Flags</h2>
            <p>A few control bits that have different uses for different frame types</p>
          </section>
          <section>
            <h2>R</h2>
            <p>A shoutout to pirates</p>
          </section>
          <section>
            <h2>Stream Identifier</h2>
            <p>Which multiplexed stream this frame is for</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Frame Types</h2>
          </section>
          <section>
            <h2>DATA</h2>
            <p>Request and Response Bodies are made of these</p>
          </section>
          <section>
            <h2>HEADERS</h2>
            <p>Request and Response Headers start with these</p>
          </section>
          <section>
            <h2>PRIORITY</h2>
            <p>Sent to change a stream's priority</p>
          </section>
          <section>
            <h2>RST_STREAM</h2>
            <p>Sent to give up on a stream</p>
          </section>
          <section>
            <h2>SETTINGS</h2>
            <p>Negotiates overall connection settings</p>
          </section>
          <section>
            <h2>PUSH_PROMISE</h2>
            <p>Headers for a response for which there was no request</p>
          </section>
          <section>
            <h2>PING</h2>
            <p>measuring round trip</p>
          </section>
          <section>
            <h2>GOAWAY</h2>
            <p>We're done here. Could be an error, could just be natual causes</p>
          </section>
          <section>
            <h2>WINDOW_UPDATE</h2>
            <p>Issues a credit for flow control</p>
          </section>
          <section>
            <h2>CONTINUATION</h2>
            <p>PUSH_PROMISE and HEADERS are the first frame of headers, but if they're too big to fit in one frame, the rest comes over in CONTINUATION frames. When a frame comes over with the END_HEADERS flag set, we know it's over</p>
          </section>
        </section>


        <section>
          <section>
            <h2>Flow Control</h2>
          </section>

          <section>
            <h2>Receiver</h2>
            <p>Each receiver advertizes how many bytes it can receive</p>
          </section>

          <section>
            <h2>Sender</h2>
            <p>Won't send more than the receiver advertizes</p>
          </section>

          <section>
            <h2>WINDOW_UPDATE</h2>
            <p>The window update frame is sent by the receiver to increase the number of bytes advertized. There is no decrement operation.</p>
          </section>

          <section>
            <h2>Connection and Streams</h2>
            <p>There's a limit advertized to both</p>
          </section>

          <section>
            <h2>Stream 0</h2>
            <p>Stream 0 is the meta stream. Frames sent to it apply to the entire connection</p>
            <p>Some frame types (e.g. Data) can't be sent to stream 0.</p>
          </section>

          <section>
            <h2>Only Applies to Data Frames</h2>
          </section>

        </section>

        <section>
          <h2>Prioritization</h2>
          <p>A client can request that a server prioritizes a certain stream over another.</p>
          <p>It is built in a tree structure so you can create requests for stream dependencies.</p>
          <p>Leaves in a tree can have different weights</p>
          <h4>A server is under no obligation to honor these requests</h4>
          <aside class="notes">
            So I punted on it for V1; however, we didn't spawn each stream into it's own gen_fsm explicity so we could have control over priority in a future version.
          </aside>
        </section>

        <section>
          <section>
            <h2>Server Push</h2>
          </section>
          <section>
            <h2>Guessing about requests that will come</h2>
          </section>
          <section>
            <h2>Static Content</h2>
            <p>Imagine inspecting HTML on the way out, and sending pushes for all the CSS, JavaScript, and Images you need.</p>
            <p>Is this exciting for APIs? <b>Maybe!</b></p>
            <aside class="notes">
              If your API has common use cases, you could push expected responses. e.g. you just did GET /shoppingcart, and you might usually see a GET /item for each item in the cart after that. While currently you might just return all that info in GET /shoppingcart, you might also take advantage of PP. You might not. This might be dumb.
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h2>Upgrading HTTP1 Requests</h2>
          </section>
          <section>
            <h2>https://</h2>
            <p>Uses TLS's "Next Protocol Negotiation"</p>
            <p>Or TLS's "Application Layer Protocol Negotiation"</p>
          </section>
          <section>
            <h2>http://</h2>
            <p>Uses "Upgrade: " header.</p>
            <p>HTTP/2 servers respond with status code </p>
            <pre>101 Switching</pre>
          </section>
        </section>

        <section>
          <h2>OMG Can I See Some Erlang Already?!</h2>
          <aside class="notes">Understanding the protocol is the hardest part. Anyone can pattern match :D</aside>
        </section>

        <section>
          <h2>Chatterbox</h2>
          <p><a href="http://github.com/joedevivo/chatterbox">Chatterbox</a></p>
        </section>

        <section>
          <section>
            <h2>Development</h2>
          </section>
          <section>
            <h2>Minimum Viable Response: NGHTTP2</h2>
          </section>
          <section>
            <h2>Firefox 37</h2>
          </section>
          <section>
            <h2>When Things Go Wrong</h2>
            <p>Building a client that breaks the rules</p>
          </section>
          <section>
            <h2>http2c APIs</h2>
            <ul>
              <li>High Level - Request/Response</li>
              <li>Mid Level - HTTP/2 Frames</li>
              <li>Low Level - Binary</li>
            </ul>
          </section>
          <section>
            <p>I needed a client that could break the rules, so I could test that the server breaks properly</p>
          </section>
          <section>
<pre><code data-trim contenteditable class="erlang">
Frames = [
            {#frame_header{length=8,type=?HEADERS,stream_id=3},
             #headers{ block_fragment=H1 }},
            {#frame_header{length=8,type=?CONTINUATION,stream_id=3},
             #continuation{block_fragment=H2}},
            %% not allowed!
            {#frame_header{length=8,type=?HEADERS,stream_id=3},
             #headers{block_fragment=H1}},
            {#frame_header{
              length=8,type=?CONTINUATION,
              flags=?FLAG_END_HEADERS,
              stream_id=3
              },
             #continuation{block_fragment=H3}}
],
http2c:send_unaltered_frames(Client, Frames),
</code></pre>
          </section>




        </section>

        <section>
          <section>
            <h2>References</h2>
          </section>
          <section>
            <h2>HTTP History References</h2>
            <ul>
              <li><a href="http://http2.github.io/faq/">HTTP/2 Official FAQ</a></li>
              <li><a href="http://daniel.haxx.se/http2/">HTTP2 Explained - Daniel Stenberg</a></li>
              <li><a href="http://chimera.labs.oreilly.com/books/1230000000545/ch09.html">High Performance Browser Networking  - Ilya Grigorik</a></li>
            </ul>
          </section>
          <section>
            <h2>HTTP/1.x RFCs</h2>
            <ul>
              <li><a href="http://tools.ietf.org/html/rfc1945">RFC 1945 - HTTP/1.0</a></li>
              <li><a href="http://tools.ietf.org/html/rfc2616">RFC 2616 - HTTP/1.1</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7230">RFC 7230 - HTTP/1.1: Message Syntax and Routing</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7231">RFC 7231 - HTTP/1.1: Semantics and Content</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7232">RFC 7232 - HTTP/1.1: Conditional Requests</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7233">RFC 7233 - HTTP/1.1: Range Requests</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7234">RFC 7234 - HTTP/1.1: Caching</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7235">RFC 7235 - HTTP/1.1: Authentication</a></li>
            </ul>
          </section>
          <section>
            <h2>HTTP/2 RFCs</h2>
            <ul>
              <li><a href="http://tools.ietf.org/html/rfc7540">RFC 7540 - HTTP/2</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7541">RFC 7541 - HPACK - Header Compression for HTTP/2</a></li>
            </ul>
          </section>
        </section>
      </div>


    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
