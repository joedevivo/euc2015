<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Chatterbox: HTTP/2 for Erlang</title>

    <meta name="description" content="An Introduction to HTTP/2 and the code that implements it">
    <meta name="author" content="Joe DeVivo">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/abba.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>Take a Chance<br/>on HTTP</h1>
          <h3>Chatterbox: HTTP/2 for Erlang</h3>
          <img src="./img/crown.png" style="border:0px"/>
          <p>
            <small>Joe DeVivo / <a href="http://twitter.com/joedevivo">@joedevivo</a></small>
          </p>
          <center>
            <div style="height: 3px; width:100px; background: #b89c30; align: center;"></div>
          </center>
        </section>

        <section>
          <h2>Chatterbox</h2>
          <p><a href="http://github.com/joedevivo/chatterbox">Here's the code!</a></p>
        </section>

        <section>
          <h2>A Brief History of HTTP</h2>
          <ul>
            <li>1991 - <a href="http://www.w3.org/Protocols/HTTP/AsImplemented.html">RFC-NULL: HTTP/0.9</a></li>
            <li>1996 - <a href="http://tools.ietf.org/html/rfc1945">RFC-1945: HTTP/1.0</a></li>
            <li>1997 - <a href="http://tools.ietf.org/html/rfc2068">RFC-2068: HTTP/1.1</a></li>
            <li>1999 - <a href="http://tools.ietf.org/html/rfc2616">RFC-2616: HTTP/1.1 (again)</a></li>
            <li>2014 - <a href="http://tools.ietf.org/html/rfc7230">RFC-7230-5: HTTP/1.1 (again (again))!</a></p>
          </ul>
          <aside class="notes">
            I start here just to show how simple it was. HTTP/1.1 was here to resolve ambiguities in HTTP/1.0 and introduce performance optimizations. In 2014's special edition remaster, HTTP/1.1 was split into SIX RFCs totaling over 292 pages
          </aside>
        </section>

        <section>
          <section>
            <h2>On HTTP/1.1's TCP Usage</h2>
          </section>
          <section>
            <h2>It uses less connections because 'Keepalive'</h2>
            <p>That's good!</p>
          </section>
          <section>
            <h2>It sequentially sends requests and receives responses in order via Pipelining</h2>
            <p>That's bad!</p>
            <p>Well, sometimes. Be responsible</p>
          </section>
          <section>
            <h2>Head of line Blocking</h2>
            <ul>
              <li>Pipelining lets you send another request before the first one responds</li>
              <li>It will not respond until the first response is fully served</li>
              <li>Most browsers disable pipelining by default</li>
            </ul>
          </section>
          <section>
            <h2>Performance Hacks</h2>
            <ul>
              <li>Spriting</li>
              <li>Inlining</li>
              <li>Concatenation</li>
              <li>Sharding</li>
            </ul>
            <aside class="notes">
              Spriting/Inlinging - Different ways of serving a large file, and then displaying different parts in different places.
              Concatenation - Manually merging javascript files, so they're one file
              Sharding - Different files on different servers = more connections open
            </aside>
          </section>

          <section>
            <h2>Transfer Sizes</h2>
            <h2>Dec/2010 - Apr/2015</h2>
            <img src="./img/chart2.png"/>
            <aside class="notes">Transfer sizes and quantities are going UP! Which would make HoL blocking worse, but also makes the performance hacks worse</aside>
          </section>
        </section>

        <section>
          <section>
            <h2>HTTP/2 Abstract</h2>
            <p>
              This specification describes an optimized expression of the semantics
              of the Hypertext Transfer Protocol (HTTP), referred to as HTTP
              version 2 (HTTP/2).  HTTP/2 enables a <b>more efficient use of network
              resources</b> and a <b>reduced perception of latency</b> by introducing <b>header
              field compression</b> and <b>allowing multiple concurrent exchanges on the
              same connection</b>.  It also introduces <b>unsolicited push of
              representations from servers</b> to clients.
            </p>
            <p>
              This specification is an alternative to, but does not obsolete, the
              HTTP/1.1 message syntax.  <b>HTTP's existing semantics remain unchanged.</b>
            </p>
          </section>

          <section>
            <h2>High Level HTTP/2</h2>
            <ul>
              <li>more efficient use of network resources</li>
              <li>reduced perception of latency</li>
              <li>header field compression</li>
              <li>allowing multiple concurrent exchanges on the same connection</li>
              <li>unsolicited push of representations from servers</li>
              <li>HTTPâ€™s existing semantics remain unchanged.</li>
            </ul>
          </section>

          <section>
            <h2>SPDY</h2>
            <p>Google tried to fix this and pretty much proved it could work</p>
            <aside class="notes">One day, the SPDY/3 draft became the HTTP/2 draft</aside>
          </section>
        </section>
        <section>
          <h2>HTTP/2</h2>
          <p>
            2015 - <a href="http://tools.ietf.org/html/rfc7540">RFC 7540</a>
          </p>
          <ul>
            <li>Keep your semantics</li>
            <li>A path to upgrading</li>
            <li>Be more efficient with connections / networking</li>
            <li class="fragment"> and Server Push!</li>
          </ul>
          <aside class="notes">
            First three are about making old things more efficient, but we're also adding efficiency in a new way with Server Push
          </aside>
        </section>

        <!-- semantics -->
        <section>
          <section>
            <h2>Keep your semantics</h2>
            <ul>
              <li>methods: GET, POST, and Friends</li>
              <li>Headers</li>
              <li>Requests</li>
              <li>Responses</li>
            </ul>
            <aside class="notes">
              If you did it before, it should still work. When I talk about "messages", I mean these
            </aside>
          </section>
          <section>
            <h2>Technically that means</h2>
            <ul>
              <li><a href="http://tools.ietf.org/html/rfc7231">RFC 7231</a>: HTTP/1.1 Semantics and Content</li>
              <li><a href="http://tools.ietf.org/html/rfc7232">RFC 7232</a>: HTTP/1.1 Conditional Request</li>
              <li><a href="http://tools.ietf.org/html/rfc7233">RFC 7233</a>: HTTP/1.1 Range Requests</li>
              <li><a href="http://tools.ietf.org/html/rfc7234">RFC 7234</a>: HTTP/1.1 Caching</li>
              <li><a href="http://tools.ietf.org/html/rfc7235">RFC 7235</a>: HTTP/1.1 Authentication</li>
              <li>And parts of <a href="http://tools.ietf.org/html/rfc7230">RFC 7230</a>: HTTP/1.1 Message Syntax and Routing</li>
            </ul>
          </section>
          <section>
            <h4 style="color: #b40f29";>Erlang</h4>
            <img style="border:none;" src="./img/webmachine2.png"/>
            <aside class="notes">
              There's an abstraction layer where we can plug chatterbox into something like webmachine for processing REST requests
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h2>Upgrading HTTP/1* Requests</h2>
          </section>
          <section>
            <h2>https://</h2>
            <p>Uses TLS's "Next Protocol Negotiation"</p>
            <p>Or TLS's "Application Layer Protocol Negotiation"</p>
            <aside class="notes">
              NPN was what was availble for SPDY, but it was never totally formalized. HTTP/2 supports both to be SPDY friendly, but recommends ALPN,
              Google discourages NPN and has said it has deprecated support for SPDY and NPN in favor of HTTP/2 and ALPN.
              Firefox and Chrome have both said they'll only make HTTP/2 connections over HTTPS
            </aside>
          </section>
          <section>
            <h2>http://</h2>
            <p>Uses "Upgrade: " header.</p>
            <p>HTTP/2 servers respond with status code </p>
            <pre>101 Switching</pre>
            <aside class="notes">I've punted on the implementation of this for now</aside>
          </section>
        </section>

        <section>
          <h2>Networking Optimizations</h2>
        </section>

        <!-- hpack -->
        <section>
          <section>
            <h2>Header Compression</h2>
            <p>HTTP is stateless</p>
            <p class="fragment">Stateless protocols are repetitive</p>
            <p class="fragment">Stateless protocols are repetitive</p>
          </section>
          <section>
            <h2>HPACK - <a href="http://tools.ietf.org/html/rfc7541">RFC 7541</a></h2>
            <p>A whole RFC just for header compression!</p>
          </section>
          <section>
            <h2>Compression Context is Stateful</h2>
            <aside class="notes">It's stateful at the connection level, but each request is still stateless</aside>
          </section>

          <section>
            <h2>What is a compression context?</h2>
            <p class="fragment">Lookup table for common and recently used headers</p>
            <aside class="notes"></aside>
          </section>

          <section data-background-transition="fade">
            <h2>The Static Table</h2>
<pre>                    +-------+--------------------+---------------+
                    | Index | Header Name        | Header Value  |
                    +-------+--------------------+---------------+
                    | 1     | :authority         |               |
                    | 2     | :method            | GET           |
                    | 3     | :method            | POST          |
                    | 4     | :path              | /             |
                    | 5     | :path              | /index.html   |
                    | 6     | :scheme            | http          |
                    | 7     | :scheme            | https         |
                    | 8     | :status            | 200           |
                    | 13    | :status            | 404           |
                    | 14    | :status            | 500           |
                    | 15    | accept-charset     |               |
                    | 16    | accept-encoding    | gzip, deflate |
                                        ...
                    | 57    | transfer-encoding  |               |
                    | 58    | user-agent         |               |
                    | 59    | vary               |               |
                    | 60    | via                |               |
                    | 61    | www-authenticate   |               |
                    +-------+--------------------+---------------+
</pre>
          </section>
          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/headers.erl#L62-L123">headers.erl:62-123</a>
<pre><code class="erlang" style="max-height:100%">                      [{1  , <<":authority">>       , undefined},
                       {2  , <<":method">>          , <<"GET">>},
                       {3  , <<":method">>          , <<"POST">>},
                       {4  , <<":path">>            , <<"/">>},
                       {5  , <<":path">>            , <<"/index.html">>},
                       {6  , <<":scheme">>          , <<"http">>},
                       {7  , <<":scheme">>          , <<"https">>},
                       {8  , <<":status">>          , <<"200">>},
                       {13 , <<":status">>          , <<"404">>},
                       {14 , <<":status">>          , <<"500">>},
                       {15 , <<"accept-charset">>   , undefined},
                       {16 , <<"accept-encoding">>  , <<"gzip, deflate">>},
                                    ...
                       {57 , <<"transfer-encoding">>, undefined},
                       {58 , <<"user-agent">>       , undefined},
                       {59 , <<"vary">>             , undefined},
                       {60 , <<"via">>              , undefined},
                       {61 , <<"www-authenticate">> , undefined}]
</code></pre>
            <aside class="notes">
              These are for really common headers. e.g. A response code of 200 is just going to be represented by "8".
              Sometimes there's no value, but the header name is what we're saving here, so 15+value is always "accept-charset", Indexes 1-61, Sometimes value, sometimes not. They're all hardcoded and are constant.
            </aside>
          </section>

          <section>
            <h2>psuedo-headers</h2>
            <ul>
              <li>:method</li>
              <li>:path</li>
              <li>:scheme</li>
              <li>:status</li>
            </ul>
            <aside class="notes">While we treat these as headers in the implementation, semantically they're not</aside>
          </section>

          <section>
            <h2>Initial Context is the Static Table</h2>
          </section>

          <section>
            <h2>The Dynamic Table</h2>
            <p>Add your own!</p>
            <p>Indexes 62+</p>
            <p>
              Bounded by size in HTTP/2 connection settings as a security precaution
            </p>
            <aside class="notes">Take a bite out of CRIME</aside>
          </section>

          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/headers.erl#L15-L27">headers.erl:15-27</a>
<pre><code data-trim class="erlang">
-type header_name() :: binary().
-type header_value():: binary().
-define(DYNAMIC_TABLE_MIN_INDEX, 62).

-record(dynamic_table, {
    table = [] :: [{pos_integer(), header_name(), header_value()}],
    max_size = 4096 :: pos_integer(),
    size = 0 :: non_neg_integer()
    }).
-type dynamic_table() :: #dynamic_table{}.
</code></pre>
          </section>

          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/hpack.erl">hpack.erl</a>
<pre><code data-trim class="erlang">
-spec encode([{binary(), binary()}], encode_context()) -> {binary(), encode_context()}.
-spec decode(binary(), decode_context()) -> {headers(), decode_context()}.
</code></pre>
          </section>

          <section>
            <h4>Encoding any header that already exists in the context doesn't change the context</h4>
<pre><code data-trim class="erlang">
StaticTable = hpack:new_encode_context(),
{HeaderBin, StaticTable} = encode([{<<":status">>, <<"200">>}], StaticTable).

StaticTable = hpack:new_decode_context(),
{[{<<":status">>, <<"200">>}], StaticTable} = decode(HeaderBin, StaticTable).
</code></pre>
          </section>

          <section>
            <h4>Encoding any header that doesn't already exists in the context changes the context</h4>
<pre><code data-trim class="erlang">
StaticTable = hpack:new_encode_context(),
{HeaderBin, NewContext} = encode([{<<":status">>, <<"600">>}], StaticTable),
NewContext =/= StaticTable,
%% Second time we try and encode this header
{HeaderBin, NewContext} = encode([{<<":status">>, <<"600">>}], NewContext).
%% Order Matters!
</code></pre>
          </section>

          <section>
            <h2>There Are Four Contexts!</h2>
            <p>Given two peers: X &amp; Y, connected over C1 </p>
            <ul>
              <li>Context A1: encoding outbound requests on X to Y over C1</li>
              <li>Context A2: decoding inbound requests on Y from X over C1</li>
              <li>Context B1: encoding outbound responses on Y to X over C1</li>
              <li>Context B2: decoding inbound responses on X from Y over C1</li>
            </ul>

            <aside class="notes">
              Two for each peer, Maybe easier to think of as one for Requests and one for Responses. If you open multiple connections, there will be 4 contexts per connection, but you wouldn't do that because you can multiplex :D
            </aside>
          </section>

          <section>
            <h2>MATH!</h2>
            <p>
              For a connection between two peers, Client and Server, Server<sub>Context</sub> and Client<sub>Context</sub> are both initialized with the values from the static table
            </p>
            <p>
              encode(Headers, Client<sub>Context</sub>) -> Client<sub>Context</sub>', EncodedBin
            </p>
            <p>
              decode(EncodedBin, Server<sub>Context</sub>) -> Server<sub>Context</sub>', Headers
            </p>
            <p>
              Client<sub>Context</sub>' == Server<sub>Context</sub>'
            </p>
          </section>


          <section>
            <h2>The Basic Case</h2>
<pre>                    +---------------+           +---------------+
                    |Peer X (Client)|           |Peer Y (Server)|
+-------------------+---------------+           +---------------+-------------------+
|                                   |           |                                   |
| +----------+   +-----------+   +--+-----------+--+   +-----------+   +----------+ |
| |Plain Req |   |Encode (A1)|   | Encoded Request |   |Decode (A2)|   |Plain Req | |
| | Headers  |-->|  Context  |-->|     Headers     |-->|  Context  |-->| Headers  | |
| +----------+   +-----------+   +--+-----------+--+   +-----------+   +----------+ |
|                                   |   Cloud   |                                   |
| +----------+   +-----------+   +--+-----------+--+   +-----------+   +----------+ |
| |Plain Resp|   |Decode (B2)|   |Encoded Response |   |Encode (B1)|   |Plain Resp| |
| | Headers  |<--|  Context  |<--|     Headers     |<--+- Context  |<--| Headers  | |
| +----------+   +-----------+   +--+-----------+--+   +-----------+   +----------+ |
|                                   |           |                                   |
|                                   |           |                                   |
+-----------------------------------+           +-----------------------------------+</pre>
          </section>
          <section>
            <h2>A More interesting case</h2>
            <pre>                    +---------------+           +---------------+
                    |Peer X (Client)|           |Peer Y (Server)|
+-------------------+---------------+           +---------------+-------------------+
|                                   |           |                                   |
| +----------+   +-----------+   +--+-----------+--+   +-----------+   +----------+ |
| |Plain Req |   |           |   | Encoded Request |   |           |   |Plain Req | |
| |Headers #1|-->|           |-->|   Headers #1    |-->|           |-->|Headers #1| |
| +----------+   |           |   +--+-----------+--+   |           |   +----------+ |
| +----------+   |           |   +--+-----------+--+   |           |   +----------+ |
| |Plain Req |   |           |   | Encoded Request |   |           |   |Plain Req | |
| |Headers #2|-->|           |-->|   Headers #2    |-->|           |-->|Headers #2| |
| +----------+   |Encode (A1)|   +--+-----------+--+   |Decode (A2)|   +----------+ |
| +----------+   |  Context  |   +--+-----------+--+   |  Context  |   +----------+ |
| |Plain Req |   |           |   | Encoded Request |   |           |   |Plain Req | |
| |Headers #3|-->|           |-->|   Headers #3    |-->|           |-->|Headers #3| |
| +----------+   |           |   +--+-----------+--+   |           |   +----------+ |
| +----------+   |           |   +--+-----------+--+   |           |   +----------+ |
| |Plain Req |   |           |   | Encoded Request |   |           |   |Plain Req | |
| |Headers #4|-->|           |-->|   Headers #4    |-->|           |-->|Headers #4| |
| +----------+   +-----------+   +--+-----------+--+   +-----------+   +----------+ |
+-----------------------------------+           +-----------------------------------+
</pre></section>
          <section>
            <h2>How "H" Packs</h2>
          </section>
          <section>
            <h2>Data Types</h2>
            <ul>
              <li>Numbers</li>
              <li>Strings</li>
            </ul>
            <aside class="notes">It's very stingy with these both, be it through encoding integers a certain way, or huffman encoding</aside>
          </section>
          <section>
            <h2>Indexed Header Field</h2>
            <pre>
                            0   1   2   3   4   5   6   7
                          +---+---+---+---+---+---+---+---+
                          | 1 |        Index (7+)         |
                          +---+---------------------------+
            </pre>
            <aside class="notes">
              A Name/Value pair already in the table. If the integer is greater than 2^7-1, then there's a way to add more using the following bytes
            </aside>
          </section>

          <section>
            <h2>Literal Header Field w/ Index</h2>
            <pre>                            0   1   2   3   4   5   6   7
                          +---+---+---+---+---+---+---+---+
                          | 0 | 1 |      Index (6+)       |
                          +---+---+-----------------------+
                          | H |     Value Length (7+)     |
                          +---+---------------------------+
                          | Value String (Length octets)  |
                          +-------------------------------+
            </pre>
            <aside class="notes">
              A Name that's already in the table, but a different value. Lol, what if index is bigger than 2^6-1, which is "63" and can easily happen! Same thing for Value Length
            </aside>
          </section>

          <section>
            <h2>Literal Header Field w/ Index</h2>
            <pre>                            0   1   2   3   4   5   6   7
                          +---+---+---+---+---+---+---+---+
                          | 0 | 1 |           0           |
                          +---+---+-----------------------+
                          | H |     Name Length (7+)      |
                          +---+---------------------------+
                          |  Name String (Length octets)  |
                          +---+---------------------------+
                          | H |     Value Length (7+)     |
                          +---+---------------------------+
                          | Value String (Length octets)  |
                          +-------------------------------+
            </pre>
            <aside class="notes">
              Neither the name nor value are in the table
            </aside>
          </section>

          <section>
            <h2>Types of Literal Fields</h2>
            <ul>
              <li>with Indexing - added to the dynamic table</li>
              <li>without Indexing - not added to the DT</li>
              <li>never Indexed - never added to any DT</li>
            </ul>
            <aside class="notes">
              All three are ways of saying the same thing, as far as "here's a header and value, but some are not compressed. "never" means no proxies can compress it either, while "without" applies to just one hop.
            </aside>
          </section>

          <section>
            <h4 style="color: #b40f29";>Erlang</h4>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/hpack.erl#L39-L75">hpack:decode</a>
<pre><code data-trim class="erlang">
decode(<<>>, HeadersAcc, C) -> {HeadersAcc, C};
%% First bit is '1', so it's an 'Indexed Header Feild'
decode(<<2#1:1,_/bits>>=B, HeaderAcc, Context) ->
    decode_indexed_header(B, HeaderAcc, Context);
%% First two bits are '01' so it's a 'Literal Header Field with Incremental Indexing'
decode(<<2#01:2,_/bits>>=B, HeaderAcc, Context) ->
    decode_literal_header_with_indexing(B, HeaderAcc, Context);
%% First four bits are '0000' so it's a 'Literal Header Field without Indexing'
decode(<<2#0000:4,_/bits>>=B, HeaderAcc, Context) ->
    decode_literal_header_without_indexing(B, HeaderAcc, Context);
%% First four bits are '0001' so it's a 'Literal Header Field never Indexed'
decode(<<2#0001:4,_/bits>>=B, HeaderAcc, Context) ->
    decode_literal_header_never_indexed(B, HeaderAcc, Context);
%% First three bits are '001' so it's a 'Dynamic Table Size Update'
decode(<<2#001:3,_/bits>>=B, HeaderAcc, Context) ->
    decode_dynamic_table_size_update(B, HeaderAcc, Context);
</code></pre>
            <aside class="notes">
              Pattern Matching makes this easy! Each of those sub clauses passes along to something that knows how to read those bytes
            </aside>
          </section>

          <section>
            <h2>Huffman Encoding</h2>
            <aside class="notes">Did you see that "H" bit? It means the string is huffman encoded. It's an option for saying more popular characters in less bytes
            </aside>
          </section>
          <section>
            <h2>Examples</h2>
            <p>
              There are tons of cool examples in <a href="http://tools.ietf.org/html/rfc7541#appendix-C">HPACK: Appendix C</a></p><p>They're so good that I turned them into <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/test/hpack_tests.erl#L61-L189">EUnit tests</a>
            </p>
          </section>
        </section>

        <!-- HPACK Example -->
        <section>
          <section>
            <h2>HPACK Tables Example</h2>
          </section>
          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/common_test/http2_frame_size_SUITE.erl#L39-L70">
              http2_frame_size_SUITE.erl#L39-L70
            </a>
            <pre><code style="max-height:100%;" class="erlang">
Headers1 = [
           {<<":path">>, <<"/">>},
           {<<"user-agent">>, <<"my cool browser">>},
           {<<"x-custom-header">>, <<"some custom value">>}
          ],
HeaderContext1 = hpack:new_encode_context(),
{HeadersBin1, HeaderContext2} = hpack:encode(Headers1, HeaderContext1),

Headers2 = [
           {<<":path">>, <<"/some_file.html">>},
           {<<"user-agent">>, <<"my cool browser">>},
           {<<"x-custom-header">>, <<"some custom value">>}
          ],
{HeadersBin2, HeaderContext3} = hpack:encode(Headers2, HeaderContext2),

Headers3 = [
           {<<":path">>, <<"/some_file.html">>},
           {<<"user-agent">>, <<"my cool browser">>},
           {<<"x-custom-header">>, <<"new value">>}
          ],
{HeadersBin3, _HeaderContext4} = hpack:encode(Headers3, HeaderContext3),
  </code></pre>
          </section>
          <section>
            <h2>Request 1</h2>
            <pre><code class="erlang">
                Headers1 = [
                 {<<":path">>, <<"/">>},
                 {<<"user-agent">>, <<"my cool browser">>},
                 {<<"x-custom-header">>, <<"some custom value">>}
                ],
  </code></pre>
          </section>
          <section>
            <h4>Wiresharked R1</h4>
<pre>
        Header: :path: /
            Representation: Indexed Header Field
            Index: <b>4</b>
        Header: user-agent: my cool browser
            Representation: Literal Header Field with Incremental Indexing - Indexed Name
            Index: <b>58</b>
            Value: <b>my cool browser</b>
        Header: x-custom-header: some custom value
            Representation: Literal Header Field with Incremental Indexing - New Name
            Name: <b>x-custom-header</b>
            Value: <b>some custom value</b>
</pre>
            <aside class="notes">Look at the first and second headers' index, and the third has none</aside>
          </section>

          <section>
            <h2>R1 Context updates</h2>
<pre><code class="erlang">
DynamicTable = [
                {62,<<"x-custom-header">>,<<"some custom value">>},
                {63,<<"user-agent">>,     <<"my cool browser">>}
              ]
</code></pre>
            <ul>
              <li>:path changes nothing</li>
              <li>"user-agent"/"my cool browser" is now Index 62</li>
              <li>"x-custom-header"/"some custom value" is now Index 62
              <li>"user-agent"/"my cool browser" is +1'd to 63</li>
            </ul>
          </section>

          <section>
            <h2>Request 2</h2>
            <pre><code class="erlang">
               Headers2 = [
                {<<":path">>, <<"/some_file.html">>},
                {<<"user-agent">>, <<"my cool browser">>},
                {<<"x-custom-header">>, <<"some custom value">>}
               ],
  </code></pre>
          </section>
          <section>
            <h4>Wiresharked R2</h4>
<pre>
        Header: :path: /some_file.html
            Representation: Literal Header Field with Incremental Indexing - Indexed Name
            Index: <b>4</b>
            Value: <b>/some_file.html</b>
        Header: user-agent: my cool browser
            Representation: Indexed Header Field
            Index: <b>64</b>
        Header: x-custom-header: some custom value
            Representation: Indexed Header Field
            Index: <b>63</b>
</pre>
            <aside class="notes">Look at those indexes? 64 &amp; 63? Didn't I just say 62 &amp; 63? Yes! It's because the encoding context is updated per header, not per request. Ordering!</aside>
          </section>
          <section>
            <h2>R2: Context updates</h2>
<pre><code class="erlang">
              [
                {62,<<":path">>,          <<"/some_file.html">>},
                {63,<<"x-custom-header">>,<<"some custom value">>},
                {64,<<"user-agent">>,     <<"my cool browser">>}
              ]
</code></pre>
            <ul>
              <li>":path"/"/some_file.html" is the new Index 62</li>
              <li>"x-custom-header"/"some custom value" is +1'd 63</li>
              <li>"user-agent"/"my cool browser" is +1'd to 64</li>
            </ul>
            <aside class="notes">
              FIFO queue. First in, First out. Falls of the end.
            </aside>
          </section>
          <section>
            <h2>Request 3</h2>
            <pre><code class="erlang">
                    Headers3 = [
                     {<<":path">>, <<"/some_file.html">>},
                     {<<"user-agent">>, <<"my cool browser">>},
                     {<<"x-custom-header">>, <<"new value">>}
                    ],
  </code></pre>
          </section>
          <section>
            <h4>Wiresharked R3</h4>
<pre>
       Header: :path: /some_file.html
            Representation: Indexed Header Field
            Index: <b>62</b>
        Header: user-agent: my cool browser
            Representation: Indexed Header Field
            Index: <b>64</b>
        Header: x-custom-header: new value
            Representation: Literal Header Field with Incremental Indexing - Indexed Name
            Index: <b>63</b>
            Value: <b>new value</b>
</pre>
          </section>
          <section>
            <h2>R3: Context updates</h2>
<pre><code class="erlang">
                [
                  {62,<<"x-custom-header">>,<<"new value">>},
                  {63,<<":path">>,          <<"/some_file.html">>},
                  {64,<<"x-custom-header">>,<<"some custom value">>},
                  {65,<<"user-agent">>,     <<"my cool browser">>}
                ]
</code></pre>
            <ul>
              <li>"x-custom-header"/"new value" is the new 62</li>
              <li>":path"/"/some_file.html" is +1'd to 63</li>
              <li>"x-custom-header"/"some custom value" is +1'd 64</li>
              <li>"user-agent"/"my cool browser" is +1'd to 65</li>
            </ul>
            <aside class="notes">
              when the sum of the sizes of name/value pairs exceedes the maximum table size, that last header falls off the end. bye!
            </aside>
          </section>
        </section>

        <!-- this is an interesting bug, but not something i have time for in this presentation. -->
        <!--section>
          <section>
            <h2>Debugging This Slide Deck</h2>
            <h2>With Wireshark</h2>
          </section>
          <section>
            <pre>
        Header: x-custom-header: new value
            Name Length: 15
            Name: x-custom-header
            Value Length: 9
            Value: new value
            Representation: Literal Header Field with Incremental Indexing - Indexed Name
            Index: 63
            </pre>
            <aside class="notes">I had such a hard time getting this to appear in wireshark.</aside>
          </section>
          <section>
            <h2>Why?</h2>
            <p>Index : 63</p>
            <p>Binary: 111111</p>
          </section>
        <section-->
        <!-- Multiplexing -->
        <section>
          <section>
            <h2>Multiplexing</h2>
            <h4>Pipelining done right</h4>
          </section>
          <section>
            <h2>Streams</h2>
            <p>There's one connection, streams are logical abstractions across it</p>
            <p>They have unique identifiers</p>
            <p>At most one Request / one Response per stream</p>
            <p>client initiated stream ids are always odd</p>
          </section>
          <section>
            <h2>Stream 0</h2>
            <p>Stream 0 is the meta stream.</p>
            <p>Frames sent to it apply to the entire connection</p>
            <p>Some frame types (e.g. Data) can't be sent to stream 0.</p>
          </section>
          <section>
            <h2>Frames</h2>
            <p>A frame's stream identifier determines <br/>which multiplexed stream it belongs to</p>
          </section>
          <section>
            <h2>One Stream Id</h2>
            <h2>per frame</h2>
            <p>A series of frames for each stream id is reconstructed on the other side, in the order they arrive</p>
          </section>
          <section>
            <h2>Order?</h2>
            <aside class="notes">header context is a piece of state, all those HPACK indexes would get out of sync if the client and server processed things in a different order</aside>
          </section>
          <section>
            <h2>Order Matters</h2>
<pre>
+---------------+           +---------------+
|Peer X (Client)|           |Peer Y (Server)|
+---------------+           +---------------+------------------------------+
                |           |                                              |
---------+   +--+-----------+--+              +-----------+   +----------+ |
         |   | Encoded Request |              |           |   |Plain Req | |
         |-->|   Headers #1    |------------->|           |-->|Headers #1| |
         |   +--+-----------+--+              |           |   +----------+ |
         |   +--+-----------+--+              |           |   <b>+----------+</b> |
         |   | Encoded Request |              |           |   <b>| Bad Req  |</b> |
         |-->|   Headers #2    |<b>------\       </b>|           |--><b>|Headers #3|</b> |
code (A1)|   +--+-----------+--+<b>   ----\-----></b>|Decode (A2)|   <b>+----------+</b> |
Context  |   +--+-----------+--+<b>  /     \     </b>|  Context  |   +----------+ |
         |   | Encoded Request |<b>-/       \    </b>|           |   |Bad Req   | |
         |-->|   Headers #3    |<b>          ---></b>|           |-->|Headers #2| |
         |   +--+-----------+--+              |           |   +----------+ |
         |   +--+-----------+--+              |           |   +----------+ |
         |   | Encoded Request |              |           |   |Plain Req | |
         |-->|   Headers #4    |------------->|           |-->|Headers #4| |
---------+   +--+-----------+--+              +-----------+   +----------+ |
                |           |                                              |
---------+   +--+-----------+--+              +-----------+   +----------+ |
code (B2)|   |Encoded Response |              |Encode (B1)|   |Plain Resp| |
Context  |<--|     Headers     |<-------------|  Context  |<--| Headers  | |
---------+   +--+-----------+--+              +-----------+   +----------+ |
----------------+           +----------------------------------------------+</pre>
          <aside class="notes">We'll explore this case in code! Don't cross the streams</aside>
          </section>
          <section>
            <h2>Jargon Alert!</h2>
            <p>A <b>connection</b> has multiple <b>streams</b> each of which can accept a single <b>request message</b>, and send a single <b>response message</b>, each message consisting of multiple <b>frames</b> in order</p>
            <aside class="notes">Messages are your HTTP/1 semantics.
          </section>
          <section>
            <h2>Handling</h2>
            <p>There are rules in the spec about how many can be "active" at a time, and what types of frames can be received when</p>
          </section>
          <section>
            <pre>
                                     +--------+
                             send PP |        | recv PP
                            ,--------|  idle  |--------.
                           /         |        |         \
                          v          +--------+          v
                   +----------+          |           +----------+
                   |          |          | send H /  |          |
            ,------| reserved |          | recv H    | reserved |------.
            |      | (local)  |          |           | (remote) |      |
            |      +----------+          v           +----------+      |
            |          |             +--------+             |          |
            |          |     recv ES |        | send ES     |          |
            |   send H |     ,-------|  open  |-------.     | recv H   |
            |          |    /        |        |        \    |          |
            |          v   v         +--------+         v   v          |
            |      +----------+          |           +----------+      |
            |      |   half   |          |           |   half   |      |
            |      |  closed  |          | send R /  |  closed  |      |
            |      | (remote) |          | recv R    | (local)  |      |
            |      +----------+          |           +----------+      |
            |           |                |                 |           |
            |           | send ES /      |       recv ES / |           |
            |           | send R /       v        send R / |           |
            |           | recv R     +--------+   recv R   |           |
            | send R /  `----------->|        |&lt;-----------'  send R / |
            | recv R                 | closed |               recv R   |
            `----------------------->|        |&lt;----------------------'
                                     +--------+
            </pre>
          <aside class="notes">
            Don't get your hopes up to high. I got excited too when I thought it was an FSM at first
          </aside>
          </section>
        </section>

        <!-- Frames -->
        <section>
          <section>
            <h2>Frames</h2>
            <pre>
        +-----------------------------------------------+
        |                 Length (24)                   |
        +---------------+---------------+---------------+
        |   Type (8)    |   Flags (8)   |
        +-+-------------+---------------+-------------------------------+
        |R|                 Stream Identifier (31)                      |
        +=+=============================================================+
        |                   Frame Payload (0...)                      ...
        +---------------------------------------------------------------+
            </pre>
          </section>
          <section>
            <h2>Type</h2>
            <p>One of 10 frame types. Each has rules for payload sizes, payload content and which flags can be set.</p>
          </section>
          <section>
            <h2>Flags</h2>
            <p>A few control bits that have different uses for different frame types</p>
          </section>
          <section>
            <h2>R</h2>
            <p>A shoutout to pirates</p>
          </section>
          <section>
            <h2>Stream Identifier</h2>
            <p>Which multiplexed stream this frame is for</p>
          </section>

                    <section>
<pre>
        +-----------------------------------------------+
        |                 Length (24)                   |
        +---------------+---------------+---------------+
        |   Type (8)    |   Flags (8)   |
        +-+-------------+---------------+-------------------------------+
        |R|                 Stream Identifier (31)                      |
        +=+=============================================================+
        |                   Frame Payload (0...)                      ...
        +---------------------------------------------------------------+
</pre>

            <h4 style="color: #b40f29";>Erlang</h4>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_frame.erl#L70-L78">http2_frame:read_binary_frame_header/1</a>
<pre><code class="erlang">
-spec read_binary_frame_header(binary()) -&gt; {frame_header(), binary()}.
read_binary_frame_header(&lt;&lt;Length:24,Type:8,Flags:8,_R:1,StreamId:31,Rem/bits&gt;&gt;) -&gt;
    Header = #frame_header{
        length = Length,
        type = Type,
        flags = Flags,
        stream_id = StreamId
    },
    {Header, Rem}.
</code></pre>
            <aside class="notes">The first 9 bytes better be a frame header. The following bytes depend on it.</aside>
          </section>
        </section>

        <section>
          <section>
            <h2>Connection Level Frame Types</h2>
          </section>
          <section>
            <h2>SETTINGS</h2>
            <p>Negotiates overall connection settings</p>
          </section>
          <section>
            <h2>PING</h2>
            <p>measuring round trip, also keeps the connection open</p>
          </section>
          <section>
            <h2>GOAWAY</h2>
            <p>We're done here. Could be an error, could just be natual causes</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Stream Level Frame Types</h2>
          </section>
          <section>
            <h2>HEADERS</h2>
            <p>Request and Response Headers start with these</p>
          </section>
          <section>
            <h2>CONTINUATION</h2>
            <p>HEADERS are the first frame of headers, but if they're too big to fit in one frame, the rest comes over in CONTINUATION frames. When a frame comes over with the END_HEADERS flag set, we know it's over</p>
          </section>
          <section>
            <h2>DATA</h2>
            <p>Request and Response Bodies are made of these</p>
          </section>
          <section>
            <h2>RST_STREAM</h2>
            <p>Sent to give up on a stream</p>
          </section>

          <section>
            <h2>A Sample Message</h2>
            <pre>
                              +-------------------------+
                              |HEADERS                  |
                              +-------------------------+
                              |CONTINUATION             |
                              +-------------------------+
                              |CONTINUATION  END_HEADERS|
                              +-------------------------+
                              |DATA                     |
                              +-------------------------+
                              |DATA                     |
                              +-------------------------+
                              |DATA          END_STREAM |
                              +-------------------------+
            </pre>
          </section>
        </section>

        <section>
          <section>
            <h2>Routing Individual Frames</h2>
          </section>

          <section>
            <h2>http2_connection</h2>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_connection.erl">http2_connection.erl</a>
            <aside class="notes">
              a gen_fsm that is the owner of the socket. It receives all these frames and has logic for routing them all
            </aside>
          </section>

          <section>
            <h4>Frame Size Errors</h4>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_connection.erl#L257-L273">http2_connection:route_frame</a>
<pre><code class="erlang">
route_frame({#frame_header{length=L}, _},
            S = #http2_connection_state{
                   connection=#connection_state{
                                 recv_settings=#settings{max_frame_size=MFS}
                                }})
    when L > MFS ->
    go_away(?FRAME_SIZE_ERROR, S);
</code></pre>
            <aside class="notes">One of least complicated parts of the spec just talks about frame size. One of the settings for the connection sets a max value, and if a frame that's bigger comes over, we're done.</aside>
          </section>
        </section>

        <section>
          <section>
            <h2>STREAMS</h2>
          </section>
          <section>
            <h2>http2_stream</h2>
            <p>A Fauxnite State Machine</p>
            <aside class="notes">A new name for an old idea! When a frame comes in associated with a stream our frame has to route it, and different things happen when streams are in differnt states</aside>
          </section>
          <section>
            <pre>
                                     +--------+
                             send PP |        | recv PP
                            ,--------|  idle  |--------.
                           /         |        |         \
                          v          +--------+          v
                   +----------+          |           +----------+
                   |          |          | send H /  |          |
            ,------| reserved |          | recv H    | reserved |------.
            |      | (local)  |          |           | (remote) |      |
            |      +----------+          v           +----------+      |
            |          |             +--------+             |          |
            |          |     recv ES |        | send ES     |          |
            |   send H |     ,-------|  open  |-------.     | recv H   |
            |          |    /        |        |        \    |          |
            |          v   v         +--------+         v   v          |
            |      +----------+          |           +----------+      |
            |      |   half   |          |           |   half   |      |
            |      |  closed  |          | send R /  |  closed  |      |
            |      | (remote) |          | recv R    | (local)  |      |
            |      +----------+          |           +----------+      |
            |           |                |                 |           |
            |           | send ES /      |       recv ES / |           |
            |           | send R /       v        send R / |           |
            |           | recv R     +--------+   recv R   |           |
            | send R /  `----------->|        |&lt;-----------'  send R / |
            | recv R                 | closed |               recv R   |
            `----------------------->|        |&lt;----------------------'
                                     +--------+
            </pre>
            <aside class="notes">All these transitions are triggered by either receiving or sending a frame. These states exist on both sides of the connection, just like encoding contexts! The difference is that when the server goes left, the client goes right, so the two structres are inverse</aside>
          </section>
          <section>
            <h2>Stream State</h2>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/include/http2.hrl#L204-L211">http2.hrl:204-211</a>
<pre><code data-trim class="erlang">
-record(stream_state, {
  stream_id = undefined :: stream_id(),
  state = idle :: stream_state_name()
}).
</code></pre>
          </section>
          <section>
            <h2>Stream Transitions</h2>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_stream.erl#L33-L230">http2_stream.erl</a>
<pre><code data-trim class="erlang">
-spec recv_frame(frame(), {stream_state(), connection_state()}) ->
                                      {stream_state(), connection_state()}.
-spec send_frame(frame(), {stream_state(), connection_state()}) ->
                                      {stream_state(), connection_state()}.
</code></pre>
          </section>
          <section>
            <h2>routing a headers frame</h2>
          </section>
          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_connection.erl#L257-L273">http2_connection:route_frame</a>
<pre><code class="erlang">
route_frame(F={H=#frame_header{stream_id=StreamId}, _Payload},
        S = #connection_state{
               decode_context=DecodeContext,
               recv_settings=#settings{initial_window_size=RecvWindowSize},
               send_settings=#settings{initial_window_size=SendWindowSize},
               streams=Streams,
               content_handler = Handler
           })
    when H#frame_header.type == ?HEADERS,
         ?IS_FLAG(H#frame_header.flags, ?FLAG_END_HEADERS) ->
    lager:debug("Received HEADERS Frame for Stream ~p", [StreamId]),
    HeadersBin = http2_frame_headers:from_frames([F]),
    {Headers, NewDecodeContext} = hpack:decode(HeadersBin, DecodeContext),
    Stream = http2_stream:new(StreamId),
</code></pre>
            <aside class="notes">
              Create a new stream because while in the idle state, we don't have a structure for it. Pull the headers of the frame with decode, and apply this frame to the newly created stream state

              This is just the handler for data frames coming in on the connection level, we pull the existing stream out of the chatterbox state, apply a stream transition to it, and put that stream back in the state</aside>
          </section>
          <section>
            <h2>http2_stream</h2>
            <p>State Machine without a Process</p>
          </section>
          <section>
            <h2>new/1</h2>
            <pre><code data-trim class="erlang">
-spec new(stream_id()) -> stream_state().
new(StreamId) ->
    #stream_state{
       stream_id=StreamId
      }.
</code></pre>
            <aside class="notes">
              new/2 is the new init/1, All of the initial state, none of the process spawning
            </aside>
          </section>
          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_connection.erl#L257-L273">http2_connection:route_frame</a>
<pre><code class="erlang">
    {Stream2, NextConnectionState} =
        http2_stream:recv_frame(F, {Stream,
                                    S#connection_state{
                                                        decode_context=NewDecodeContext
                                                     }}),

</code></pre>
            <aside class="notes">after that, back in http2_connection</aside>
          </section>
          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_stream.erl#L36-L47">http2_stream:recv_frame</a>
<pre><code class="erlang">
recv_frame(F={FH = #frame_header{
              stream_id=StreamId,
              type=?HEADERS
             }, _Payload},
           {State = #stream_state{state=idle},
            ConnectionState})
when ?IS_FLAG(FH#frame_header.flags, ?FLAG_END_STREAM) ->
    {State#stream_state{
      stream_id = StreamId,
      state = half_closed_remote,
      incoming_frames = [F]
     }, ConnectionState};
</code></pre>
            <aside class="notes">First clause will handle transitions from idle to half_closed_remote, via HEADERS frame with END_STREAM flag set</aside>
          </section>
          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_stream.erl#L50-L60">http2_stream:recv_frame</a>
<pre><code data-trim class="erlang">
recv_frame(F={_FH = #frame_header{
              stream_id=StreamId,
              type=?HEADERS
             }, _Payload},
           {State = #stream_state{state=idle},
            ConnectionState}) ->
    {State#stream_state{
      stream_id = StreamId,
      state = open,
      incoming_frames = [F]
     }, ConnectionState};
</code></pre>
            <aside class="notes">This one goes to open, because it's a headers frame, but not the end of stream</aside>
          </section>
          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_connection.erl#L257-L273">http2_connection:route_frame</a>
<pre><code class="erlang">
    {NewStreamState, NewConnectionState} =
        Handler:handle(
          NextConnectionState,
          Headers,
          Stream2),
    {next_state, connected, NewConnectionState#connection_state{
                              streams = [{StreamId, NewStreamState}|Streams]
                             }};
</code></pre>
          <aside class="notes">Since this is the end_stream case we're processing, we know to run the handler (which is just for static files at this point. but others could come soon... *cough* webmachine! then we put the stream back in the connection's state</aside>
          </section>
        </section>

        <section>
          <section>
            <h2>Flow Control</h2>
            <p>Applied to both the Connection as a whole and Individual Streams</p>
            <aside class="notes">Another cool thing about http/2 is flow control. gives peers a chance to catch up with eachother.</aside>
          </section>

          <section>
            <h2>Only Applies to Data Frames</h2>
            <aside class="notes">Allows control frames to get in</aside>
          </section>

          <section>
            <h2>Receiver</h2>
            <p>Each receiver advertises how many bytes it can receive</p>
          </section>

          <section>
            <h2>Sender</h2>
            <p>Won't send more than the receiver advertises</p>
          </section>

          <section>
            <h2>WINDOW_UPDATE</h2>
            <h4>NEW FRAME TYPE!</h4>
            <p>
              The window update frame is sent by the receiver to increase the number of bytes advertised. There is no decrement operation.
            </p>
            <p>This is the only frame type that works on both the connection and stream level</p>
          </section>
          <section>
            <h2>Implementing Flow Control</h2>
            <aside class="notes">
              We only have to worry about it with DATA frames, but at both the connection and stream level. assume we add some state to the stream_state to keep track of the recv window size</aside>
          </section>

          <section>
            <h4>Sending Response Data</h4>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/chatterbox_static_content_handler.erl#L43-L60">chatterbox_static_content_handler</a>
<pre><code style="max-height:100%;" class="erlang">
            Ext = filename:extension(File),
            MimeType = case Ext of
                ".js" -> <<"text/javascript">>;
                ".html" -> <<"text/html">>;
                ".css" -> <<"text/css">>;
                _ -> <<"unknown">>
            end,
            {ok, Data} = file:read_file(File),
            ResponseHeaders = [
                {<<":status">>, <<"200">>},
                {<<"content-type">>, MimeType}
            ],
            {HeaderFrame, NewContext} = http2_frame_headers:to_frame(StreamId, ResponseHeaders, EncodeContext),
            DataFrames = http2_frame_data:to_frames(StreamId, Data, SS),
            {NewContext, [HeaderFrame|DataFrames]};
</code></pre>
            <aside class="notes"></aside>
          </section>

          <section>
             <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/chatterbox_static_content_handler.erl#L71-L77">chatterbox_static_content_handler</a>
<pre><code class="erlang">
      %% This is a baller fold right here. Fauxnite State Machine at its finest.
      lists:foldl(
          fun(Frame, State) ->
              http2_stream:send_frame(Frame, State)
          end,
          {Stream, NewConnectionState},
          Frames).
</code></pre>
            <aside class="notes"></aside>
          </section>
          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_stream.erl#L197-L228">http2_stream:send_frame</a>
<pre><code data-trim class="erlang">
send_frame(F={#frame_header{length=L,type=?DATA},_Data},
           {StreamState = #stream_state{
                      send_window_size=SSWS},
            ConnectionState = #connection_state{
                                 send_window_size=CSWS}
           })
  when SSWS >= L, CSWS >= L ->
    Transport:send(Socket, http2_frame:to_binary(F)),
    {StreamState#stream_state{
       send_window_size=SSWS-L
      },
     ConnectionState#connection_state{
       send_window_size=CSWS-L
      }
    };
</code></pre>
            <aside class="notes">
              Send the frame and subtract it's length from your remaining credits on the connection and stream level, if both windows are large enough
            </aside>
          </section>

          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_stream.erl#L197-L228">http2_stream:send_frame</a>
<pre><code class="erlang">
send_frame(F={#frame_header{
                 type=?DATA
                },_Data},
           {StreamState = #stream_state{
                      queued_frames = QF
                     },
           ConnectionState = #connection_state{}}) ->
    {StreamState#stream_state{
       queued_frames=QF ++ [F] %% I know, I know queue:in
      },
     ConnectionState};
</code></pre>
            <aside class="notes">If you notice here, I'm just queuing up the frames I can't send.</aside>
          </section>
          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_stream.erl#L157-L181">http2_stream:recv_frame(?WINDOW_UPDATE)</a>
<pre><code class="erlang" style="max-height:100%">
%% needs a WINDOW_UPDATE clause badly
recv_frame({#frame_header{type=?WINDOW_UPDATE, stream_id=StreamId},
            #window_update{
               window_size_increment=WSI
              }
           },
           {State=#stream_state{
                      stream_id=StreamId,
                      send_window_size=SWS,
                      queued_frames=QF
                     },
            ConnectionState}) ->
    NewSendWindow = WSI + SWS,
    NewState = State#stream_state{
                 send_window_size=NewSendWindow,
                 queued_frames=[]
                },
    lists:foldl(
      fun(Frame, StreamAndConn) -> send_frame(Frame, StreamAndConn) end,
      {NewState, ConnectionState},
      QF);
</code></pre>
            <aside class="notes">Queued frames? This only applies to the Stream!</aside>
          </section>

          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_connection.erl#L491-L498">http2_connection:route_frame</a>
<pre><code class="erlang" style="max-height:100%">
route_frame({H=#frame_header{stream_id=0}, #window_update{window_size_increment=WSI}},
            S = #connection_state{
                   socket=_Socket,
                   send_window_size=SWS
                  })
    when H#frame_header.type == ?WINDOW_UPDATE ->
    lager:debug("Stream 0 Window Update: ~p", [WSI]),
    {next_state, connected, S#connection_state{send_window_size=SWS+WSI}};
</code></pre>
            <aside class="notes">Updating it for the connection is easier. But there's still a TODO here, have you guessed it? If frames weren't being sent because of the connection window being too small, the streams that stalled need to be reminded to wake up and start sending</aside>
          </section>
        </section>
        <section>
          <section>
            <h2>Prioritization</h2>
            <p>A client can request that a server prioritizes a certain stream over another.</p>
            <p>It is built in a tree structure so you can create requests for stream dependencies.</p>
            <p>Leaves in a tree can have different weights</p>
            <h4>A server is under no obligation to honor these requests</h4>
            <aside class="notes">
              So I punted on it for V1; however, we didn't spawn each stream into it's own gen_fsm explicity so we could have control over priority in a future version.
            </aside>
          </section>
          <section>
            <h2>PRIORITY</h2>
            <h4>NEW FRAME TYPE</h4>
            <p>Sent to change a stream's priority</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Server Push</h2>
          </section>
          <section>
            <h2>Multiple Responses per Request</h2>
            <p class="fragment">Each response on a new stream</p>
            <p class="fragment">Server initiated streams have even identifiers</p>
          </section>
          <section>
            <h2>Static Content</h2>
            <p>Imagine inspecting HTML on the way out, and sending pushes for all the CSS, JavaScript, and Images you need.</p>
            <p>Is this exciting for APIs? <b>Yes!</b></p>
            <aside class="notes">
              If your response contains a link, push promises are for you!
              While I have implemented the frames needed to send these, I haven't actually done it yet.
            </aside>
          </section>
          <section>
            <h2>PUSH_PROMISE</h2>
            <h4>NEW FRAME TYPE<h4>
            <p>Headers for a Server Push message</p>
            <!--p> and the choice of a new generation</p-->
          </section>
          <section>
            <h2>CONTINUATION</h2>
            <p>Can also follow a PUSH_PROMISE</p>
          </section>
          <section>
            <h2>A Sample Push Message</h2>
            <pre>
              +-------------------------+
              |PUSH_PROMISE             |
              +-------------------------+
              |CONTINUATION             |
              +-------------------------+
              |CONTINUATION  END_HEADERS|
              +-------------------------+
              |DATA                     |
              +-------------------------+
              |DATA                     |
              +-------------------------+
              |DATA          END_STREAM |
              +-------------------------+
            </pre>
          </section>
        </section>

        <section>
          <section>
            <h2>Without a connection, what can we do?</h2>
          </section>

          <section>
            <h2>RFC 7540 - <a href="http://tools.ietf.org/html/rfc7540#section-3.5">Section 3.5</a></h2>
            <pre>
The client connection preface starts with a sequence of 24 octets,
which in hex notation is:
     0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
That is, the connection preface starts with the string
     "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
This sequence MUST be followed by a SETTINGS frame
(Section 6.5), which MAY be empty.
            </pre>
          </section>

          <section>
            <h2>RFC 7540 - <a href="http://tools.ietf.org/html/rfc7540#section-3.5">Section 3.5</a></h2>
            <pre>
The server connection preface consists of a potentially empty
SETTINGS frame (Section 6.5) that MUST be the first frame the server
sends in the HTTP/2 connection.

The SETTINGS frames received from a peer as part of the connection
preface MUST be acknowledged (see Section 6.5.3) after sending the
connection preface.
            </pre>
          </section>
          <section>
            <h2>RFC 7540 - <a href="http://tools.ietf.org/html/rfc7540#section-6.5.3">Section 6.5.3</a></h2>
            <pre>
Once all values have been processed, the
recipient MUST immediately emit a SETTINGS frame with the ACK flag
set.  Upon receiving a SETTINGS frame with the ACK flag set, the
sender of the altered parameters can rely on the setting having been
applied.
If the sender of a SETTINGS frame does not receive an acknowledgement
within a reasonable amount of time, it MAY issue a connection error
(Section 5.4.1) of type SETTINGS_TIMEOUT.
            </pre>
          </section>
          <section>
            <h2>tl;dr</h2>
            <p>A connection start must</p>
            <ul>
              <li>Send the TEXT: <b>"PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"</b></li>
              <li>Must send a SETTINGS frame</li>
              <li>Must have that SETTINGS frame ACK'd</li>
              <li>Must receive a SETTINGS frame from the client</li>
              <li>Must ACK that client's SETTINGS frame</li>
            </ul>
          </section>
          <section>
            <h2>SETTINGS</h2>
            <ul>
              <li>SETTINGS_HEADER_TABLE_SIZE</li>
              <li>SETTINGS_ENABLE_PUSH</li>
              <li>SETTINGS_MAX_CONCURRENT_STREAMS</li>
              <li>SETTINGS_INITIAL_WINDOW_SIZE</li>
              <li>SETTINGS_MAX_FRAME_SIZE</li>
              <li>SETTINGS_MAX_HEADER_LIST_SIZE</li>
            </ul>
            <aside class="notes">
              TODO: What are these?
            </aside>
          </section>
          <section>
            <h2>RFC 7540 - <a href="http://tools.ietf.org/html/rfc7540#section-4">Section 4</a></h2>
            <pre>
Once the HTTP/2 connection is established, endpoints can begin
exchanging frames.
            </pre>
            <aside class="notes">Pity party: see how many sections and out of order things I had to find for this piece of flow?</aside>
          </section>
          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_connection.erl#L531-L534">http2_connection:handle_info</a>
<pre><code data-trim class="erlang">
-define(PREAMBLE, "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n").

handle_info({_, _Socket, &lt;&lt;?PREAMBLE,Bin/bits&gt;&gt;}, _, S) ->
    gen_fsm:send_event(self(), {start_frame,Bin}),
    {next_state, settings_handshake, S};
</code></pre>
          </section>

          <section>
            <h2>Settings Handshake State</h2>
          </section>

          <section>
            <h2>What it does it</h2>
            <ol>
              <li>Send our server SETTINGS frame</li>
              <li>Wait for client SETTINGS frame</li>
              <li>Wait client's SETTINGS ACK</li>
              <li>Send ACK of client settings</li>
              <li>Backlog any frames before 3 and 4 are done</li>
              <li>Transition to connected state</li>
            </ol>
          </section>

          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_connection.erl#L91-L127">http2_connection:settings_handshake/2</a>
<pre><code data-trim style="max-height:100%;" class="erlang">
settings_handshake({start_frame, <<>>},
                   S = #connection_state{
                          socket=Socket,
                          recv_settings=ServerSettings
                   }) ->
    http2_frame_settings:send(Socket, ServerSettings),
    NewState = S#http2_connection_state{
                 frame_backlog=queue:new()
                },
    settings_handshake_loop({false,false}, [], NewState).
</code></pre>
            <aside class="notes">
              We're going to ignore the case where more than the preamble came over in the first packet, but it's handled in the code. Trust me.
            </aside>
          </section>

          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_connection.erl#L133-L162">settings_handshake_loop/3</a>
<pre><code data-trim class="erlang" style="max-height:100%">
settings_handshake_loop({true, true}, [], State) ->
    gen_fsm:send_event(self(), backlog),
    {next_state, connected, State};
settings_handshake_loop(Done, [], State=#connection_state{
                                           socket=Socket,
                                           frame_backlog=FB
                                          }) ->
    Frame = {FH, _} = http2_frame:read(Socket),

    case FH#frame_header.type of
        ?SETTINGS ->
            settings_handshake_loop(Done, [Frame], State);
        _ ->
            %% loop right back into this state after putting one on the backlog
            settings_handshake_loop(Done, [], State#connection_state{
                                                frame_backlog=queue:in(Frame, FB)
                                               })
    end;
</code></pre>
            <aside class="notes">
              If we're done, transition to connected. Otherwise read a frame. If it's a settings frame, it's handled by other clauses. Otherwise we'll add it to the backlog for when we transition to connected.
            </aside>
          </section>
          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_connection.erl#L163-169">settings_handshake_loop/3</a>
<pre><code data-trim class="erlang">
settings_handshake_loop({_ReceivedAck, ReceivedClientSettings},
                       [{FH, _FPayload}|SettingsFramesTail],
                       State)
  when ?IS_FLAG(FH#frame_header.flags, ?FLAG_ACK) ->
    settings_handshake_loop({true, ReceivedClientSettings},
                            SettingsFramesTail,
                            State);
</code></pre>
            <aside class="notes">
              It's settings! Is it an ACK? then flip the first bit to true
            </aside>
          </section>
          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_connection.erl#L170-L180">settings_handshake_loop/3</a>
<pre><code data-trim class="erlang">
settings_handshake_loop({ReceivedAck, _ReceivedClientSettings},
                       [{_FH, FPayload}|SettingsFramesTail],
                       S=#connection_state{}) ->
    ClientSettings = http2_frame_settings:overlay(S#connection_state.send_settings, FPayload),
    http2_frame_settings:ack(S#connection_state.socket),

    settings_handshake_loop({ReceivedAck, true},
                            SettingsFramesTail,
                            S#connection_state{
                              send_settings=ClientSettings
                             }).
</code></pre>
            <aside class="notes">
              It's settings, but not an ACK. set the connection level client settings and flip the second bit to true
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h2>Development</h2>
            <aside class="notes">Now that we're in the connected state, let's connect</aside>
          </section>
          <section>
            <h2>Minimum Viable Response: NGHTTP2</h2>
            <p>No content handler, just a hard coded response</p>
            <aside class="notes">Great, now what? This was enough to get through the settings handshake</aside>
          </section>
          <section>
            <h2>Firefox 37</h2>
            <p>This Slide Deck!</p>
            <aside class="notes">Learned alot here, like how to split data into frame sized response chunks. Pages would partially render because some content was less than max frame size, and some was more.</aside>
          </section>
          <section>
            <h2>When Things Go Wrong</h2>
            <p>Building a client that breaks the rules</p>
            <aside class="notes">
              I needed a client that could break the rules, so I could test that the server breaks properly
            </aside>
          </section>
          <section>
            <h2>http2c APIs</h2>
            <ul>
              <li>High Level - Request/Response Message Level (Keep your semantics!)</li>
              <li>Mid Level - HTTP/2 Frames</li>
              <li>Low Level - Binary</li>
            </ul>
          </section>
          <section>
            <p>RFC 7540 <a href="http://tools.ietf.org/html/rfc7540#section-4.3">Section 4.3</a></p>
<pre>
Each header block is processed as a discrete unit.  Header blocks
MUST be transmitted as a contiguous sequence of frames, with no
interleaved frames of any other type or from any other stream.  The
last frame in a sequence of HEADERS or CONTINUATION frames has the
END_HEADERS flag set.  The last frame in a sequence of PUSH_PROMISE
or CONTINUATION frames has the END_HEADERS flag set.  This allows a
header block to be logically equivalent to a single frame.
</pre>
            <p>RFC 7540 <a href="http://tools.ietf.org/html/rfc7540#section-6.2">Section 6.2</a></p>
<pre>
END_HEADERS (0x4):  When set, bit 2 indicates that this frame
  contains an entire header block (Section 4.3) and is not followed
  by any CONTINUATION frames.

A HEADERS frame without the END_HEADERS flag set MUST be followed
by a CONTINUATION frame for the same stream.  A receiver MUST
treat the receipt of any other type of frame or a frame on a
different stream as a connection error (Section 5.4.1) of type
PROTOCOL_ERROR.
</pre>
          </section>
          <section>
            <h2>TL;DR</h2>
            <p>Once a HEADERS frame is received on Stream X, only accept CONTINUATION frames on Stream X until one comes over with the END_HEADERS flag set</p>
            <p>If any other frame type, or frames from any other Stream come over, send a GOAWAY frame with a PROTOCOL_ERROR code</p>
          </section>

          <section>
            <h2>Joe DeVivo</h2>
            <img src="./img/joe.png" height="300"/>
            <p class="fragment">Reading RFCs so you don't have to, since 2015</p>
            <aside class="notes">This has been another episode of..</aside>
          </section>

          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/common_test/header_continuation_SUITE.erl#L75-80">header_continuation_SUITE</a>
<pre><code style="max-height:100%;" class="erlang">
Frames = [
   {#frame_header{length=8,type=?HEADERS,stream_id=3},
    #headers{ block_fragment=H1 }},
   {#frame_header{length=8,type=?CONTINUATION,stream_id=3},
    #continuation{block_fragment=H2}},
   %% not allowed!
   {#frame_header{length=8,type=?HEADERS,stream_id=3},
    #headers{block_fragment=H1}},
   {#frame_header{
     length=8,type=?CONTINUATION,
     flags=?FLAG_END_HEADERS,
     stream_id=3
     },
    #continuation{block_fragment=H3}}
],
http2c:send_unaltered_frames(Client, Frames),
</code></pre>
          </section>

          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/common_test/header_continuation_SUITE.erl#L85-L94">header_continuation_SUITE</a>
<pre><code data-trim class="erlang">
%% No response on stream 3
Resp = http2c:get_frames(Client, 3),
?assertEqual(0, length(Resp)),

%% One GOAWAY frame on stream 0
Resp2 = http2c:get_frames(Client, 0),
1 = length(Resp2),

%% Protocol Error
[{_GoAwayH, GoAway}] = Resp2,
?PROTOCOL_ERROR = GoAway#goaway.error_code,
</code></pre>
          </section>

          <section>
            <h2>http2_connection: continuation state</h2>
            <ul>
              <li>Any time a HEADERS frame is received, enter CONTINUATION state</li>
              <li>In that state, only accept CONTINUATION frames from that stream</li>
              <li>when a CONTINUATION with the END HEADERS flag is set, transition back to 'connected'</li>
              <li>If any other frame type comes in (or CONTINUATION with other stream id), send GOAWAY with CONNECTION ERROR</li>
            </ul>
          </section>
          <section>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/src/http2_connection.erl#L214-L231"></a>
<pre><code data-trim class="erlang">
continuation(start_frame,
             S = #connection_state{
                    socket=Socket,
                    continuation_stream_id = StreamId
                   }) ->
    Frame = {FH,_} = http2_frame:read(Socket),
    Response = case {FH#frame_header.stream_id, FH#frame_header.type} of
                   {StreamId, ?CONTINUATION} ->
                       route_frame(Frame, S);
                   _ ->
                       go_away(?PROTOCOL_ERROR, S)
               end,
    gen_fsm:send_event(self(), start_frame),
    Response;
continuation(_, State) ->
    go_away(?PROTOCOL_ERROR, State).
</code></pre>
          </section>
          <section>
            <h2>Take out the bad frame</h2>
            <a href="https://github.com/joedevivo/chatterbox/blob/euc2015/common_test/header_continuation_SUITE.erl#L19-L53">Successful Test!</a>
<pre><code data-trim class="erlang">
Resp = http2c:get_frames(Client, 3),
?assertEqual(2, length(Resp)).

Stream0 = http2c:get_frames(Client, 0),
?assertEqual(0, length(Stream0)),
</code></pre>
          <aside class="notes">If I took out the bad frame, which I did for another test, I'd assert this instead</aside>
         </section>
        </section>

        <section>
          <h2>THANKS!</h2>
          <p>p.s. there are a bunch of references later, keep reading!</p>
          <p><a href="http://github.com/joedevivo/chatterbox">Here's the code again!</a></p>
        </section>
        <section>
          <section>
            <h2>References</h2>
          </section>
          <section>
            <h2>HTTP History References</h2>
            <ul>
              <li><a href="http://http2.github.io/faq/">HTTP/2 Official FAQ</a></li>
              <li><a href="http://daniel.haxx.se/http2/">HTTP2 Explained - Daniel Stenberg</a></li>
              <li><a href="http://chimera.labs.oreilly.com/books/1230000000545/ch09.html">High Performance Browser Networking  - Ilya Grigorik</a></li>
              <li><a href="http://www.oreilly.com/webops-perf/free/HTTP2-high-perf-browser-networking.csp">And the HTTP/2 add on</a></li>
            </ul>
          </section>
          <section>
            <h2>HTTP/1.x RFCs</h2>
            <ul>
              <li><a href="http://tools.ietf.org/html/rfc1945">RFC 1945 - HTTP/1.0</a></li>
              <li><a href="http://tools.ietf.org/html/rfc2616">RFC 2616 - HTTP/1.1</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7230">RFC 7230 - HTTP/1.1: Message Syntax and Routing</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7231">RFC 7231 - HTTP/1.1: Semantics and Content</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7232">RFC 7232 - HTTP/1.1: Conditional Requests</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7233">RFC 7233 - HTTP/1.1: Range Requests</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7234">RFC 7234 - HTTP/1.1: Caching</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7235">RFC 7235 - HTTP/1.1: Authentication</a></li>
            </ul>
          </section>
          <section>
            <h2>HTTP/2 RFCs</h2>
            <ul>
              <li><a href="http://tools.ietf.org/html/rfc7540">RFC 7540 - HTTP/2</a></li>
              <li><a href="http://tools.ietf.org/html/rfc7541">RFC 7541 - HPACK - Header Compression for HTTP/2</a></li>
            </ul>
          </section>
        </section>


      </div>


    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        width: 1200,
        controls: true,
        progress: true,
        history: true,
        center: true,
        slideNumber: true,
        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
